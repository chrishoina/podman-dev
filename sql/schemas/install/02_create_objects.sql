-- NOTE: This script is not intended to be used directly but through
--       install_pdb.sql

SET DEFINE '^'
SET ESCAPE '\'
SET VERIFY OFF
SET ECHO OFF

PROMPT INFO: Creating Live SQL SCHEMAS Objects...

COLUMN :CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT NEW_VALUE CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT NOPRINT
VARIABLE CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT VARCHAR2(255)
SET FEEDBACK OFF
BEGIN
    :CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT := CASE WHEN DBMS_DB_VERSION.VERSION < 23 THEN '../../utilities/create_before_update_trigger.sql' ELSE '../../utilities/nothing.sql' END;
END;
/
SET FEEDBACK ON
SET TERMOUT OFF
SELECT :CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT FROM DUAL;
SET TERMOUT ON

WHENEVER SQLERROR EXIT 1

CREATE OR REPLACE TYPE VC2_TABLE_T AS TABLE OF VARCHAR2(32767 BYTE);
/

CREATE TABLE PARAMETERS (
    NAME VARCHAR2(128 BYTE) NOT NULL,
    CONSTRAINT PARAMETERS_PK PRIMARY KEY ( NAME ),
    -- NOTE: Limiting the parameter names to a bound regular expression of
    --       uppercase leters, digits and underscores starting by an uppercase
    --       letter. Not using star or plus on purpose so that no catastrophic
    --       backtrack is possible
    CONSTRAINT PARAMETERS_CHK1 CHECK ( REGEXP_LIKE( NAME, '\^[[:upper:]][[:upper:][:digit:]]{0,127}(_[[:upper:][:digit:]]{1,126}){0,63}$' ) ),
    VALUE VARCHAR2(4000 BYTE)
)
ENABLE PRIMARY KEY USING INDEX;

CREATE OR REPLACE FUNCTION IS_PARAMETER_NAME_VALID( P_NAME VARCHAR2 ) RETURN BOOLEAN IS
BEGIN
    RETURN REGEXP_LIKE( P_NAME, '\^[[:upper:]][[:upper:][:digit:]]{0,127}(_[[:upper:][:digit:]]{1,126}){0,63}$' );
END IS_PARAMETER_NAME_VALID;
/
CREATE OR REPLACE FUNCTION DOES_PARAMETER_EXIST( P_NAME VARCHAR2 ) RETURN BOOLEAN IS
    L_COUNT INTEGER;
BEGIN
    SELECT
        COUNT(1)
    INTO
        L_COUNT
    FROM
        PARAMETERS
    WHERE
        NAME = P_NAME;

    RETURN L_COUNT > 0;
END DOES_PARAMETER_EXIST;
/
CREATE OR REPLACE FUNCTION GET_PARAMETER( P_NAME VARCHAR2 ) RETURN VARCHAR2 IS
    L_VALUE PARAMETERS.VALUE%TYPE;
BEGIN
    SELECT
        VALUE
    INTO
        L_VALUE
    FROM
        PARAMETERS
    WHERE
        NAME = P_NAME;
    RETURN L_VALUE;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter "' || P_NAME || '" does not exist' );
END GET_PARAMETER;
/
CREATE OR REPLACE PROCEDURE SET_PARAMETER( P_NAME VARCHAR2, P_VALUE VARCHAR2 ) IS
BEGIN
    IF NOT IS_PARAMETER_NAME_VALID( P_NAME => P_NAME ) THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter name "' || P_NAME || '" is invalid.' );
    END IF;
    IF NVL( LENGTHB( P_VALUE ), 0 ) > 4000 THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter value for "' || P_NAME || '" exceeds 4000 characters.' );
    END IF;

    MERGE INTO PARAMETERS
        USING DUAL
        ON ( PARAMETERS.NAME = P_NAME )
    WHEN MATCHED THEN
        UPDATE SET PARAMETERS.VALUE = P_VALUE
    WHEN NOT MATCHED THEN
        INSERT
            ( NAME, VALUE )
        VALUES
            ( P_NAME, P_VALUE );
END SET_PARAMETER;
/
CREATE OR REPLACE PROCEDURE REMOVE_PARAMETER( P_NAME VARCHAR2 ) IS
BEGIN
    DELETE FROM PARAMETERS WHERE NAME = P_NAME;
END REMOVE_PARAMETER;
/

BEGIN
    -- NOTE: Using AES256 algorithm which requires a 256 bit (32 Byte)
    --       encryption key. Genrated with RAWTOHEX( DBMS_CRYPTO.RANDOMBYTES( 32 ) )
    SET_PARAMETER( 'ENCRYPTION_KEY', 'E750108D8F478D77CC68C593F51D89F9834EC92D30C9216FE9D2F24A955B9504' );
    -- Note: generated with DBMS_CRYPTO.RANDOMBYTES( 16 )
    SET_PARAMETER( 'ENCRYPTION_IV', '7B3A272F1CB520395702EEA465227E70' );
END;
/

CREATE OR REPLACE PACKAGE UTILITIES IS
    FUNCTION BOOLEAN_TO_YN( P_VALUE BOOLEAN ) RETURN VARCHAR2;
    FUNCTION YN_TO_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_CODE_LANGUAGE( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_CODE_LANGUAGE_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_DATABASE_VERSION( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_DATABASE_VERSION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_CONENT_ACTION( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_CONENT_ACTION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_SLUG( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_SLUG_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION STRING_TO_SLUG( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION STRING_TO_ERROR_REASON( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION STRING_TO_BASE64( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION VC2_TABLE_TO_CLOB( P_VC2_TABLE VC2_TABLE_T ) RETURN CLOB;
    FUNCTION GET_SHARE_KEY RETURN VARCHAR2;
    FUNCTION GET_CLOB_SUBSTRING( P_CLOB IN OUT NOCOPY CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE BOOLEAN DEFAULT TRUE ) RETURN VARCHAR2;
    FUNCTION GET_CLOB_SUBSTRING_SQL( P_CLOB CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE_YN VARCHAR2 DEFAULT 'Y' ) RETURN VARCHAR2;
    FUNCTION STRING_TO_CONTAINS_QUERY( P_STRING VARCHAR2 ) RETURN VARCHAR2 DETERMINISTIC;
    FUNCTION HEX_ENCRYPT( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION HEX_DECRYPT( P_HEX_STRING VARCHAR2 ) RETURN VARCHAR2;
END UTILITIES;
/
CREATE OR REPLACE PACKAGE BODY UTILITIES IS
    FUNCTION BOOLEAN_TO_YN( P_VALUE BOOLEAN ) RETURN VARCHAR2 IS
        INVALID_VALUE EXCEPTION;
    BEGIN
        IF P_VALUE IS NULL THEN
            RAISE INVALID_VALUE;
        END IF;
        RETURN CASE WHEN P_VALUE THEN 'Y' ELSE 'N' END;
    END;
    FUNCTION YN_TO_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        RETURN P_VALUE = 'Y';
    END;

    FUNCTION IS_VALID_YN_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'Y', 'N' );
    END IS_VALID_YN_BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_YN_BOOLEAN( P_VALUE ) );
    END IS_VALID_YN_BOOLEAN_YN;
    FUNCTION IS_VALID_CODE_LANGUAGE( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'PL_SQL', 'QUICK_SQL', 'JAVASCRIPT' );
    END IS_VALID_CODE_LANGUAGE;
    FUNCTION IS_VALID_CODE_LANGUAGE_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_CODE_LANGUAGE( P_VALUE ) );
    END IS_VALID_CODE_LANGUAGE_YN;
    FUNCTION IS_VALID_DATABASE_VERSION( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( '8', '9', '10', '11', '12', '18', '19', '21', '23' );
    END IS_VALID_DATABASE_VERSION;
    FUNCTION IS_VALID_DATABASE_VERSION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_DATABASE_VERSION( P_VALUE ) );
    END IS_VALID_DATABASE_VERSION_YN;
    FUNCTION IS_VALID_CONENT_ACTION( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'VIEW', 'LIKE', 'EXECUTE', 'FAVORITE' );
    END IS_VALID_CONENT_ACTION;
    FUNCTION IS_VALID_CONENT_ACTION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_CONENT_ACTION( P_VALUE ) );
    END IS_VALID_CONENT_ACTION_YN;
    FUNCTION IS_VALID_SLUG( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN LENGTH( P_VALUE ) BETWEEN 6 AND 64 AND REGEXP_LIKE( P_VALUE, '\^[a-z0-9]{1,59}([-][a-z0-9]{1,57}){0,29}[-][0-9]{4}$' );
    END IS_VALID_SLUG;
    FUNCTION IS_VALID_SLUG_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_SLUG( P_VALUE ) );
    END IS_VALID_SLUG_YN;

    FUNCTION STRING_TO_SLUG_STRING( P_STRING VARCHAR2 ) RETURN VARCHAR2 DETERMINISTIC IS
        L_SLUG_STRING VARCHAR2( 59 ) := LOWER( TRIM( SUBSTR( P_STRING, 1, 59 ) ) );

        INVALID_STRING EXCEPTION;
    BEGIN
        IF P_STRING IS NULL THEN
            RAISE INVALID_STRING;
        END IF;

        -- NOTE: Replace non-alpha characters with dashes
        L_SLUG_STRING := REGEXP_REPLACE( L_SLUG_STRING, '[\^a-z0-9-]', '-' );
        -- NOTE: Replace repeated dashes with a single dash
        L_SLUG_STRING := REGEXP_REPLACE( L_SLUG_STRING, '[-]{2,59}', '-' );
        L_SLUG_STRING := TRIM( BOTH '-' FROM L_SLUG_STRING );
        RETURN L_SLUG_STRING;
    END STRING_TO_SLUG_STRING;
    FUNCTION STRING_TO_SLUG( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        L_SLUG VARCHAR2( 64 ) := STRING_TO_SLUG_STRING( P_STRING );

        INVALID_STRING EXCEPTION;
    BEGIN
        IF P_STRING IS NULL THEN
            RAISE INVALID_STRING;
        END IF;

        L_SLUG := L_SLUG || '-' || LPAD( FLOOR( DBMS_RANDOM.VALUE( LOW => 0, HIGH => 10000 ) ), 4, '0' );
        RETURN L_SLUG;
    END STRING_TO_SLUG;
    FUNCTION STRING_TO_ERROR_REASON( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        C_ERROR_REASON_PREFIX CONSTANT VARCHAR2(40) := q'[error="body"; error_description*=UTF-8'']';
        -- NOTE: Escaping consumes at most 3 characters per character. Minus 40 of the prefix. Floored. 32K / 3 = 10.9K
        C_STRING_MAX_LENGTH CONSTANT NUMBER := 10900;

        L_STRING VARCHAR2( C_STRING_MAX_LENGTH );

        INVALID_STRING EXCEPTION;
    BEGIN
        IF P_STRING IS NULL THEN
            RAISE INVALID_STRING;
        END IF;
        IF NVL( LENGTH( P_STRING ), 0 ) > C_STRING_MAX_LENGTH THEN
            -- NOTE: Subtracting 3 because of the ellipsis
            L_STRING := TRIM( SUBSTR( 1, C_STRING_MAX_LENGTH - 3 ) ) || '...';
        ELSE
            L_STRING := P_STRING;
        END IF;

        RETURN 'error="body"; error_description*=UTF-8''''' || SYS.UTL_URL.ESCAPE(
            URL => L_STRING,
            ESCAPE_RESERVED_CHARS => TRUE,
            URL_CHARSET => 'AL32UTF8'
        );
    END STRING_TO_ERROR_REASON;

    FUNCTION STRING_TO_BASE64( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN UTL_RAW.CAST_TO_VARCHAR2( UTL_ENCODE.BASE64_ENCODE( UTL_RAW.CAST_TO_RAW( P_STRING ) ) );
    END STRING_TO_BASE64;

    FUNCTION VC2_TABLE_TO_CLOB( P_VC2_TABLE VC2_TABLE_T ) RETURN CLOB IS
        L_CLOB CLOB;
        L_SIZE NUMBER;
    BEGIN
        SYS.DBMS_LOB.CREATETEMPORARY( LOB_LOC => L_CLOB, CACHE => TRUE, DUR => SYS.DBMS_LOB.SESSION );

        FOR I IN 1 .. P_VC2_TABLE.COUNT LOOP
            L_SIZE := NVL( LENGTHB( P_VC2_TABLE( I ) ), 0 );
            SYS.DBMS_LOB.WRITEAPPEND( LOB_LOC => L_CLOB, AMOUNT => L_SIZE, BUFFER => P_VC2_TABLE( I ) );
        END LOOP;

        RETURN L_CLOB;
    EXCEPTION
        WHEN OTHERS THEN
            IF SYS.DBMS_LOB.ISTEMPORARY( LOB_LOC => L_CLOB ) = 1 THEN
                SYS.DBMS_LOB.FREETEMPORARY( LOB_LOC => L_CLOB );
            END IF;
            RAISE;
    END VC2_TABLE_TO_CLOB;

    FUNCTION GET_SHARE_KEY RETURN VARCHAR2 IS
    BEGIN
        RETURN DBMS_RANDOM.STRING( 'A', 10 );
    END GET_SHARE_KEY;

    FUNCTION GET_CLOB_SUBSTRING( P_CLOB IN OUT NOCOPY CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE BOOLEAN DEFAULT TRUE ) RETURN VARCHAR2 IS
        L_CLOB_LENGTH NUMBER := NVL( DBMS_LOB.GETLENGTH( P_CLOB ), 0 );
        L_RESULT VARCHAR2(32767);

        INVALID_PARAMETER EXCEPTION;
    BEGIN
        IF
            P_LENGTH < 1
            OR P_LENGTH > 32767
            OR P_START < 1
            OR P_START > P_LENGTH
            OR (
                P_ELLIPSIZE
                AND (
                    (
                        P_START = 1
                        -- NOTE: at least 1 character besides the ellipsis
                        AND P_LENGTH < 4
                    )
                    OR (
                        P_START > 1
                        -- NOTE: at least 1 character besides the ellipsis
                        AND P_LENGTH < 7
                    )
                )
            )
        THEN
            RAISE INVALID_PARAMETER;
        END IF;

        L_RESULT := DBMS_LOB.SUBSTR( LOB_LOC => P_CLOB, AMOUNT => P_LENGTH, OFFSET => P_START );

        IF NOT P_ELLIPSIZE THEN
            RETURN L_RESULT;
        END IF;

        IF P_START > 1 THEN
            L_RESULT := '...' || TRIM( SUBSTR( L_RESULT, 1, LENGTH( L_RESULT ) - 3 ) );
        END IF;

        -- NOTE: Only ellipzise from the end if it is not the actual end of the CLOB
        IF P_START + P_LENGTH < L_CLOB_LENGTH THEN
            L_RESULT := TRIM( SUBSTR( L_RESULT, 1, LENGTH( L_RESULT ) - 3 ) ) || '...';
        END IF;

        RETURN L_RESULT;
    END GET_CLOB_SUBSTRING;
    -- NOTE: Not using NOCOPY because SQL prevents the use of out parameters
    FUNCTION GET_CLOB_SUBSTRING_SQL( P_CLOB CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE_YN VARCHAR2 DEFAULT 'Y' ) RETURN VARCHAR2 IS
        L_CLOB CLOB := P_CLOB;
    BEGIN
        RETURN GET_CLOB_SUBSTRING(
            P_CLOB => L_CLOB,
            P_LENGTH => P_LENGTH,
            P_START => P_START,
            P_ELLIPSIZE => P_ELLIPSIZE_YN = 'Y'
        );
    END GET_CLOB_SUBSTRING_SQL;

    FUNCTION STRING_TO_CONTAINS_QUERY( P_STRING VARCHAR2 ) RETURN VARCHAR2 DETERMINISTIC IS
    BEGIN
        -- SEE: https://docs.oracle.com/en/database/oracle/oracle-database/19/ccref/oracle-text-CONTAINS-query-operators.html#CCREF-GUID-5BA618D7-45DA-4253-BB0D-313970EA7C5D
        RETURN 'FUZZY({' || REPLACE( P_STRING, '}', '\}' ) || '}, 30, 200)';
    END STRING_TO_CONTAINS_QUERY;

    FUNCTION HEX_ENCRYPT( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        L_ENCRYPTION_KEY RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_KEY' ) );
        L_ENCRYPTION_IV RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_IV' ) );
    BEGIN
        RETURN RAWTOHEX( DBMS_CRYPTO.ENCRYPT(
            SRC => UTL_I18N.STRING_TO_RAW( DATA => P_STRING ),
            TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
            KEY => L_ENCRYPTION_KEY,
            IV => L_ENCRYPTION_IV
        ) );
    END HEX_ENCRYPT;

    FUNCTION HEX_DECRYPT( P_HEX_STRING VARCHAR2 ) RETURN VARCHAR2 IS
    L_ENCRYPTION_KEY RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_KEY' ) );
        L_ENCRYPTION_IV RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_IV' ) );
    BEGIN
        RETURN UTL_I18N.RAW_TO_CHAR( DATA => DBMS_CRYPTO.DECRYPT(
            SRC => HEXTORAW( P_HEX_STRING ),
            TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
            KEY => L_ENCRYPTION_KEY,
            IV => L_ENCRYPTION_IV
        ) );
    END HEX_DECRYPT;
END UTILITIES;
/

CREATE TABLE SCHEMA_CREATION_JOBS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCHEMA_CREATION_JOBS_PK PRIMARY KEY ( ID ),
    NUMBER_OF_SCHEMAS INTEGER DEFAULT ON NULL 1 NOT NULL,
    CONSTRAINT SCHEMA_CREATION_JOBS_CHK1 CHECK ( NUMBER_OF_SCHEMAS > 0 ),
    ARE_SCHEMAS_READ_ONLY VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT SCHEMA_CREATION_JOBS_CHK2 CHECK ( ARE_SCHEMAS_READ_ONLY IN ( 'Y', 'N' ) ),
    STATUS VARCHAR2(32 BYTE) DEFAULT ON NULL 'NEW' NOT NULL,
    CONSTRAINT SCHEMA_CREATION_JOBS_CHK3 CHECK ( STATUS IN ( 'NEW', 'DONE' ) ),
    ERROR CLOB,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6)
)
ENABLE PRIMARY KEY USING INDEX;
@@^CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT SCHEMA_CREATION_JOBS

CREATE TABLE SCHEMAS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCHEMAS_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(30 BYTE) NOT NULL,
    CONSTRAINT SCHEMAS_UQ1 UNIQUE ( NAME ) USING INDEX ( CREATE UNIQUE INDEX SCHEMAS_IDX1 ON SCHEMAS( NAME ) ),
    ALIAS VARCHAR2(255 BYTE),
    -- NOTE: Client IDs are 32 characters and 96 when HEX encrypted
    CLIENT_ID VARCHAR2(96 BYTE),
    -- NOTE: Client secrets are 32 characters and 96 when HEX encrypted
    CLIENT_SECRET VARCHAR2(128 BYTE),
    STATUS VARCHAR2(32 BYTE) DEFAULT ON NULL 'NEW' NOT NULL,
    CONSTRAINT SCHEMAS_CHK1 CHECK ( STATUS IN ( 'NEW', 'CREATED', 'GRANTED', 'REST_ENABLED', 'LOCKED_DOWN', 'REGISTERED', 'DROPPING', 'DROPPED' ) ),
    IS_READ_ONLY VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT SCHEMAS_CHK2 CHECK ( IS_READ_ONLY IN ( 'Y', 'N' ) ),
    CREATION_ERROR CLOB,
    CREATION_JOB_ID NUMBER NOT NULL,
    CONSTRAINT SCHEMAS_SCH_CREATION_JOBS_FK FOREIGN KEY ( CREATION_JOB_ID ) REFERENCES SCHEMA_CREATION_JOBS( ID ),
    -- DROPPING_ERROR VARCHAR2(4000 BYTE),
    -- DROPPING_JOB_ID NUMBER NOT NULL,
    -- CONSTRAINT SCHEMAS_SCH_DROPPING_JOBS_FK FOREIGN KEY ( DROPPING_JOB_ID ) REFERENCES SCHEMA_DROPPING_JOBS( ID ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
@@^CREATE_BEFORE_UPDATE_TRIGGER_SCRIPT SCHEMAS

CREATE OR REPLACE PACKAGE SCHEMA_MANAGEMENT AS
    PROCEDURE VALIDATE_SCHEMA_CREATION_PARAMETERS;
    PROCEDURE AUTHENTICATE_TO_METADATA_DATABASE;
    FUNCTION GENERATE_SCHEMA_NAME RETURN VARCHAR2;
    FUNCTION GENERATE_SCHEMA_PASSWORD RETURN VARCHAR2;
    PROCEDURE CREATE_SCHEMA( P_SCHEMA_NAME VARCHAR2 DEFAULT GENERATE_SCHEMA_NAME() );
    FUNCTION REST_ENABLE_SCHEMA( P_SCHEMA_NAME VARCHAR2 ) RETURN JSON_OBJECT_T;
    -- PROCEDURE LOCKDOWN_SCHEMA( P_SCHEMA_ID SCHEMAS.ID%TYPE );
    PROCEDURE REQUEST_SCHEMA_REGISTRATION( P_SCHEMA_ID SCHEMAS.ID%TYPE );
    PROCEDURE PROCESS_SCHEMA_CREATION_JOB( P_SCHEMA_CREATION_JOB_ID SCHEMA_CREATION_JOBS.ID%TYPE );
END SCHEMA_MANAGEMENT;
/

CREATE OR REPLACE PACKAGE BODY SCHEMA_MANAGEMENT AS
    PROCEDURE VALIDATE_SCHEMA_CREATION_PARAMETERS IS
        L_REQURED_PARAMETERS VC2_TABLE_T := VC2_TABLE_T(
            'DATABASE_ID',
            'METADATA_DATABASE_BASE_URL',
            'METADATA_DATABASE_SCHEMA_ALIAS',
            'METADATA_DATABASE_SCHEMA_CLIENT_ID',
            'METADATA_DATABASE_SCHEMA_CLIENT_SECRET'
        );
        L_PARAMETER_NAME PARAMETERS.NAME%TYPE;
    BEGIN
        FOR I IN 1..L_REQURED_PARAMETERS.COUNT LOOP
            L_PARAMETER_NAME := L_REQURED_PARAMETERS( I );
            IF NOT DOES_PARAMETER_EXIST( L_PARAMETER_NAME ) THEN
                RAISE_APPLICATION_ERROR( -20000, 'Schema creation job cannot be processed because the "' || L_PARAMETER_NAME || '" parameter has not been set' );
            END IF;
            IF GET_PARAMETER( 'DATABASE_ID' ) IS NULL THEN
                RAISE_APPLICATION_ERROR( -20000, 'Schema creation job cannot be processed because the "' || L_PARAMETER_NAME || '" parameter value is NULL' );
            END IF;
        END LOOP;
    END VALIDATE_SCHEMA_CREATION_PARAMETERS;

    PROCEDURE AUTHENTICATE_TO_METADATA_DATABASE IS
    BEGIN
        APEX_WEB_SERVICE.OAUTH_AUTHENTICATE(
            P_TOKEN_URL => GET_PARAMETER( 'METADATA_DATABASE_BASE_URL' ) || GET_PARAMETER( 'METADATA_DATABASE_SCHEMA_ALIAS' ) || '/oauth/token',
            P_CLIENT_ID => UTILITIES.HEX_DECRYPT( GET_PARAMETER( 'METADATA_DATABASE_SCHEMA_CLIENT_ID' ) ),
            P_CLIENT_SECRET => UTILITIES.HEX_DECRYPT( GET_PARAMETER( 'METADATA_DATABASE_SCHEMA_CLIENT_SECRET' ) ),
            P_FLOW_TYPE => APEX_WEB_SERVICE.OAUTH_CLIENT_CRED
        );
        IF APEX_WEB_SERVICE.G_STATUS_CODE != 200 THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while registering the schema. OAuth authentication request to the metadata database returned with status ' || APEX_WEB_SERVICE.G_STATUS_CODE );
        END IF;
    END AUTHENTICATE_TO_METADATA_DATABASE;

    FUNCTION GENERATE_SCHEMA_NAME RETURN VARCHAR2 IS
        C_SCHEMA_NAME_PREFIX CONSTANT VARCHAR2(4) := 'SQL_';
        C_MAX_TRIES CONSTANT NUMBER := 100;

        L_SCHEMA_NAME VARCHAR2(30);

        L_ITERATIONS NUMBER := 0;
        L_DOES_SCHEMA_EXISTS VARCHAR2(1);
    BEGIN
        LOOP
            IF L_ITERATIONS >= C_MAX_TRIES THEN
                RAISE_APPLICATION_ERROR( -20000, 'Could not generate a new schema name. Maximum tries exceeded.' );
            END IF;

            L_ITERATIONS := L_ITERATIONS + 1;

            -- NOTE: Adding the SQL_ prefix to differentiate user schemas from other
            --       schemas in the DB
            -- 'X' - Returns string is in uppercase alpha-numeric characters
            L_SCHEMA_NAME := C_SCHEMA_NAME_PREFIX || DBMS_RANDOM.STRING( 'X', 26 );

            SELECT
                CASE WHEN COUNT(1) > 0 THEN 'Y' ELSE 'N' END AS DOES_SCHEMA_EXISTS
            INTO
                L_DOES_SCHEMA_EXISTS
            FROM
                ALL_USERS
            WHERE
                USERNAME = L_SCHEMA_NAME;
        EXIT WHEN L_DOES_SCHEMA_EXISTS != 'Y';
        END LOOP;

        RETURN L_SCHEMA_NAME;
    END GENERATE_SCHEMA_NAME;

    -- NOTE: Function to generate new passwords. Passwords can contain lower
    --       case letters, upper case letters, digits, and special characters.
    --       A minimum required number of characters can be specified for each
    --       type
    FUNCTION GENERATE_SCHEMA_PASSWORD RETURN VARCHAR2 IS
        C_MAX_PASSWORD_LENGTH CONSTANT NUMBER := 30;

        C_MIN_LOWERCASE CONSTANT NUMBER := 1;
        C_MIN_UPPERCASE CONSTANT NUMBER := 1;
        C_MIN_NUMBERS CONSTANT NUMBER := 1;
        C_MIN_SPECIAL CONSTANT NUMBER := 1;

        C_SPECIAL_CHARACTERS CONSTANT VARCHAR2( 4 ) := '!#$@';

        L_PASSWORD VARCHAR2( C_MAX_PASSWORD_LENGTH );
        L_COUNT NUMBER := 0;

        FUNCTION SHUFFLE_PASSWORD( P_PASSWORD VARCHAR2 ) RETURN VARCHAR2 IS
            L_I INTEGER;
            L_R INTEGER;
            L_C CHAR(1);
            L_PASSWORD VARCHAR2( C_MAX_PASSWORD_LENGTH ) := P_PASSWORD;
        BEGIN
            FOR L_I IN REVERSE 2 .. LENGTH( L_PASSWORD ) - 1 LOOP
                L_R := TRUNC( DBMS_RANDOM.VALUE( 1, L_I + 1 ) );
                L_C := SUBSTR( L_PASSWORD, L_I, 1 );
                L_PASSWORD := SUBSTR( L_PASSWORD, 1, L_I - 1 ) || SUBSTR( L_PASSWORD, L_R, 1 ) || SUBSTR( L_PASSWORD, L_I + 1 );
                L_PASSWORD := SUBSTR( L_PASSWORD, 1, L_R - 1 ) || L_C || SUBSTR( L_PASSWORD, L_R + 1 );
            END LOOP;

            RETURN L_PASSWORD;
        END SHUFFLE_PASSWORD;
    BEGIN
        -- Add enough upper case to satisfy the minimum
        -- 'U' - Returns string is in uppercase alpha characters
        L_PASSWORD := DBMS_RANDOM.STRING( 'U', C_MIN_UPPERCASE );
        L_COUNT := L_COUNT + C_MIN_UPPERCASE;

        -- Add enough lower case to satisfy the minimum
        -- 'L' - Returns string is in lowercase alpha characters
        L_PASSWORD := L_PASSWORD || DBMS_RANDOM.STRING( 'L', C_MIN_LOWERCASE );
        L_COUNT := L_COUNT + C_MIN_LOWERCASE;

        -- Add enough digits to satisfy the minimum
        FOR i IN 1 .. C_MIN_NUMBERS LOOP
            L_PASSWORD := L_PASSWORD || TRUNC( DBMS_RANDOM.VALUE( 1, 9 ) );
        END LOOP;
        L_COUNT := L_COUNT + C_MIN_NUMBERS;

        -- And finally enough special characters
        L_PASSWORD:= L_PASSWORD || SUBSTR( C_SPECIAL_CHARACTERS, TRUNC( DBMS_RANDOM.VALUE( 1, LENGTH( C_SPECIAL_CHARACTERS ) ) ), C_MIN_SPECIAL );
        L_COUNT := L_COUNT + C_MIN_SPECIAL;

        -- Randomly fill the rest
        -- 'X' - Returns string is in uppercase alpha-numeric characters
        L_PASSWORD := L_PASSWORD || DBMS_RANDOM.STRING( 'X', C_MAX_PASSWORD_LENGTH - L_COUNT );
        L_PASSWORD := SHUFFLE_PASSWORD( L_PASSWORD );

        RETURN L_PASSWORD;
    END GENERATE_SCHEMA_PASSWORD;

    PROCEDURE CREATE_SCHEMA( P_SCHEMA_NAME VARCHAR2 DEFAULT GENERATE_SCHEMA_NAME() ) IS
    BEGIN
        IF P_SCHEMA_NAME IS NULL THEN
            RAISE_APPLICATION_ERROR( -20000, 'Cannot create a user with an empty name' );
        END IF;

        -- NOTE: There's no need to store the password since we'll use the
        --       client ID and client secret.
        EXECUTE IMMEDIATE 'CREATE USER ' || DBMS_ASSERT.ENQUOTE_NAME( P_SCHEMA_NAME ) || ' IDENTIFIED BY ' || DBMS_ASSERT.ENQUOTE_NAME( GENERATE_SCHEMA_PASSWORD() ) || ' DEFAULT TABLESPACE USERS QUOTA 10M ON USERS';
    END CREATE_SCHEMA;

    FUNCTION REST_ENABLE_SCHEMA( P_SCHEMA_NAME VARCHAR2 ) RETURN JSON_OBJECT_T IS
        L_SCHEMA_ALIAS ORDS_METADATA.DBA_ORDS_URL_MAPPINGS.PATTERN%TYPE := LOWER( P_SCHEMA_NAME );
        L_CLIENT_ID ORDS_METADATA.USER_ORDS_CLIENTS.CLIENT_ID%TYPE;
        L_CLIENT_SECRET ORDS_METADATA.USER_ORDS_CLIENTS.CLIENT_SECRET%TYPE;

        L_RESULT JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        ORDS_METADATA.ORDS.ENABLE_SCHEMA(
            P_ENABLED => TRUE,
            P_SCHEMA => P_SCHEMA_NAME,
            P_URL_MAPPING_TYPE => 'BASE_PATH',
            -- NOTE: Force lower-case for URLs to avoid confusion 
            P_URL_MAPPING_PATTERN => L_SCHEMA_ALIAS,
            P_AUTO_REST_AUTH => TRUE
        );
        -- Create OAuth client to act in name of the new schema
        ORDS_METADATA.OAUTH_ADMIN.CREATE_CLIENT(
            P_SCHEMA => P_SCHEMA_NAME,
            P_NAME => P_SCHEMA_NAME,
            P_GRANT_TYPE => 'client_credentials',
            P_OWNER => P_SCHEMA_NAME,
            P_DESCRIPTION => 'LIVE SQL Schema client',
            P_ORIGINS_ALLOWED => 'https://localhost,https://livesql-stg.oracle.com,https://livesql.oracle.com',
            P_REDIRECT_URI => NULL,
            P_SUPPORT_EMAIL => 'support@oracle.com',
            P_SUPPORT_URI => 'https://support.oracle.com',
            P_PRIVILEGE_NAMES => NULL
        );
        ORDS_METADATA.OAUTH_ADMIN.GRANT_CLIENT_ROLE(
            P_SCHEMA => P_SCHEMA_NAME,
            P_CLIENT_NAME => P_SCHEMA_NAME,
            P_ROLE_NAME => 'SQL Developer'
        );
        COMMIT;

        SELECT
            ORDS_METADATA.OAUTH_CLIENTS.CLIENT_ID,
            ORDS_METADATA.OAUTH_CLIENTS.CLIENT_SECRET
        INTO
            L_CLIENT_ID,
            L_CLIENT_SECRET
        FROM
            ORDS_METADATA.OAUTH_CLIENTS JOIN ORDS_METADATA.ORDS_SCHEMAS ON
                ORDS_METADATA.ORDS_SCHEMAS.PARSING_SCHEMA = P_SCHEMA_NAME
                AND ORDS_METADATA.OAUTH_CLIENTS.NAME = P_SCHEMA_NAME
                AND ORDS_METADATA.OAUTH_CLIENTS.SCHEMA_ID = ORDS_METADATA.ORDS_SCHEMAS.ID;

        L_RESULT.PUT( 'alias', L_SCHEMA_ALIAS );
        L_RESULT.PUT( 'client_id', L_CLIENT_ID );
        L_RESULT.PUT( 'client_secret', L_CLIENT_SECRET );

        RETURN L_RESULT;
    END REST_ENABLE_SCHEMA;

    -- TODO: Is this still needed? Since when you create a schema, it doesn't have any role, permissions, grants, and so on
    -- Lockdown the Schema ( Remove Grants/Privileges, add limits and quotas )
    /*PROCEDURE LOCKDOWN_SCHEMA( P_SCHEMA_ID SCHEMAS.ID%TYPE )
    IS
    BEGIN
        -- Revoke all object privileges
        FOR obj_priv IN ( SELECT * FROM USER_TAB_PRIVS WHERE GRANTEE = P_SCHEMA_NAME ) LOOP
            EXECUTE IMMEDIATE 'REVOKE ALL PRIVILEGES ON ' || obj_priv.TABLE_NAME || ' FROM ' || P_SCHEMA_NAME;
        END LOOP;

        -- Revoke all system privileges
        -- TODO: review how to revoke all privileges
        FOR sys_priv IN ( SELECT * FROM USER_SYS_PRIVS WHERE GRANTEE = P_SCHEMA_NAME ) LOOP
            EXECUTE IMMEDIATE 'REVOKE ' || sys_priv.PRIVILEGE || ' FROM ' || P_SCHEMA_NAME;
        END LOOP;

        -- Set resource limits
        EXECUTE IMMEDIATE 'ALTER USER ' || DBMS_ASSERT.QUALIFIED_SQL_NAME( P_SCHEMA_NAME ) || ' SESSIONS_PER_USER 1';

        -- Set storage quota
        EXECUTE IMMEDIATE 'ALTER USER ' || DBMS_ASSERT.QUALIFIED_SQL_NAME( P_SCHEMA_NAME ) || ' QUOTA 10M ON USERS';

        -- Commit the changes
        COMMIT;
    END;*/

    PROCEDURE REQUEST_SCHEMA_REGISTRATION( P_SCHEMA_ID SCHEMAS.ID%TYPE ) IS
        L_BODY CLOB;
        L_RESPONSE CLOB;
    BEGIN
        SELECT
            JSON_OBJECT(
                KEY 'database_id' VALUE GET_PARAMETER( 'DATABASE_ID' ),
                KEY 'database_schema_id' VALUE ID,
                KEY 'database_schema_creatn_job_id' VALUE CREATION_JOB_ID,
                KEY 'name' VALUE NAME,
                KEY 'is_read_only' VALUE IS_READ_ONLY,
                KEY 'alias' VALUE ALIAS,
                KEY 'client_id' VALUE CLIENT_ID,
                KEY 'client_secret' VALUE CLIENT_SECRET
                RETURNING CLOB
            )
        INTO
            L_BODY
        FROM
            SCHEMAS
        WHERE
            ID = P_SCHEMA_ID
            -- TODO: Change to LOCKED when lock down is implemented
            AND STATUS = 'REST_ENABLED';

        AUTHENTICATE_TO_METADATA_DATABASE();

        APEX_WEB_SERVICE.CLEAR_REQUEST_HEADERS;
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(1).NAME := 'Authorization';
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(1).VALUE := 'Bearer ' || APEX_WEB_SERVICE.OAUTH_GET_LAST_TOKEN();
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(2).NAME := 'Content-Type';
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(2).VALUE := 'application/json';

        L_RESPONSE := APEX_WEB_SERVICE.MAKE_REST_REQUEST(
            P_URL => GET_PARAMETER( 'METADATA_DATABASE_BASE_URL' ) || GET_PARAMETER( 'METADATA_DATABASE_SCHEMA_ALIAS' ) || '/api/schemas/',
            P_HTTP_METHOD => 'POST',
            P_BODY => L_BODY
        );
        IF APEX_WEB_SERVICE.G_STATUS_CODE != 201 THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while registering the schema. Registration request returned with HTTP status code ' || APEX_WEB_SERVICE.G_STATUS_CODE );
        END IF;

        UPDATE
            SCHEMAS
        SET
            STATUS = 'REGISTERED'
        WHERE
            ID = P_SCHEMA_ID;
        COMMIT;
    END REQUEST_SCHEMA_REGISTRATION;

    PROCEDURE PROCESS_SCHEMA_CREATION_JOB( P_SCHEMA_CREATION_JOB_ID SCHEMA_CREATION_JOBS.ID%TYPE ) IS
        L_NUMBER_OF_SCHEMAS SCHEMA_CREATION_JOBS.NUMBER_OF_SCHEMAS%TYPE;
        L_ARE_SCHEMAS_READ_ONLY SCHEMA_CREATION_JOBS.ARE_SCHEMAS_READ_ONLY%TYPE;
        L_STATUS SCHEMA_CREATION_JOBS.STATUS%TYPE;
        L_DATABASE_ID PARAMETERS.VALUE%TYPE;
        L_ERROR SCHEMA_CREATION_JOBS.ERROR%TYPE;
        L_SCHEMAS_ERRORS_COUNT INTEGER := 0;
        L_SCHEMAS_ERRORS CLOB;
    BEGIN
        VALIDATE_SCHEMA_CREATION_PARAMETERS();

        SELECT
            NUMBER_OF_SCHEMAS,
            ARE_SCHEMAS_READ_ONLY,
            STATUS,
            ERROR
        INTO
            L_NUMBER_OF_SCHEMAS,
            L_ARE_SCHEMAS_READ_ONLY,
            L_STATUS,
            L_ERROR
        FROM
            SCHEMA_CREATION_JOBS
        WHERE
            ID = P_SCHEMA_CREATION_JOB_ID;

        IF L_STATUS != 'NEW' OR L_ERROR IS NOT NULL THEN
            RAISE_APPLICATION_ERROR( -20000, 'Schema creation job cannot be processed because either its status is not NEW or it has errors' );
        END IF;

        DBMS_LOB.CREATETEMPORARY(
            LOB_LOC => L_SCHEMAS_ERRORS,
            CACHE => FALSE,
            DUR => DBMS_LOB.CALL
        );

        DECLARE
            L_CURRENT_SCHEMA_NAME SCHEMAS.NAME%TYPE;
            L_CURRENT_SCHEMA_ID SCHEMAS.ID%TYPE;
            L_REST_DETAILS JSON_OBJECT_T;
            L_REST_ALIAS SCHEMAS.ALIAS%TYPE;
            L_REST_CLIENT_ID SCHEMAS.CLIENT_ID%TYPE;
            L_REST_CLIENT_SECRET SCHEMAS.CLIENT_SECRET%TYPE;
            L_CURRENT_CREATION_ERROR SCHEMAS.CREATION_ERROR%TYPE;
        BEGIN
            FOR I IN 1 .. L_NUMBER_OF_SCHEMAS LOOP
                INSERT INTO
                    SCHEMAS (
                        NAME,
                        IS_READ_ONLY,
                        STATUS,
                        CREATION_JOB_ID
                    )
                    VALUES (
                        GENERATE_SCHEMA_NAME(),
                        L_ARE_SCHEMAS_READ_ONLY,
                        'NEW',
                        P_SCHEMA_CREATION_JOB_ID
                    )
                    RETURNING
                        ID,
                        NAME
                    INTO
                        L_CURRENT_SCHEMA_ID,
                        L_CURRENT_SCHEMA_NAME;
                COMMIT;

                BEGIN
                    CREATE_SCHEMA( P_SCHEMA_NAME => L_CURRENT_SCHEMA_NAME );

                    UPDATE
                        SCHEMAS
                    SET
                        STATUS = 'CREATED'
                    WHERE
                        ID = L_CURRENT_SCHEMA_ID;
                    COMMIT;

                    EXECUTE IMMEDIATE 'GRANT CONNECT TO ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) );
                    -- LIVE_SQL_SAMPLE_SCHEMAS_USER is a read-only role for sample schemas
                    EXECUTE IMMEDIATE 'GRANT LIVE_SQL_SAMPLE_SCHEMAS_USER TO ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) );
                    -- LIVE_SQL_READ_ONLY_USER is a role that holds all the privileges for read-only users so that they're easy to modify
                    EXECUTE IMMEDIATE 'GRANT LIVE_SQL_READ_ONLY_USER TO ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) );

                    IF L_ARE_SCHEMAS_READ_ONLY != 'Y' THEN
                        EXECUTE IMMEDIATE 'GRANT RESOURCE TO ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) );
                        IF DBMS_DB_VERSION.VERSION >= 23 THEN
                            -- Grant the privilege to schema with SYS privilege, this could not be done using the LIVE_SQL_READ_WRITE_USER role.
                            SYS.GRANT_EXECUTE_ON_JAVASCRIPT_TO_SCHEMA( L_CURRENT_SCHEMA_NAME );
                        END IF;
                        -- LIVE_SQL_READ_WRITE_USER is a role that holds all the privileges for read-write users so that they're easy to modify
                        EXECUTE IMMEDIATE 'GRANT LIVE_SQL_READ_WRITE_USER TO ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) );
                        EXECUTE IMMEDIATE 'ALTER USER ' || DBMS_ASSERT.ENQUOTE_NAME( DBMS_ASSERT.SCHEMA_NAME( L_CURRENT_SCHEMA_NAME ) ) || ' QUOTA 10M ON SYSAUX';
                    END IF;

                    UPDATE
                        SCHEMAS
                    SET
                        STATUS = 'GRANTED'
                    WHERE
                        ID = L_CURRENT_SCHEMA_ID;
                    COMMIT;

                    L_REST_DETAILS := REST_ENABLE_SCHEMA( L_CURRENT_SCHEMA_NAME );
                    L_REST_ALIAS := L_REST_DETAILS.GET_STRING( 'alias' );
                    L_REST_CLIENT_ID := L_REST_DETAILS.GET_STRING( 'client_id' );
                    L_REST_CLIENT_SECRET := L_REST_DETAILS.GET_STRING( 'client_secret' );

                    UPDATE
                        SCHEMAS
                    SET
                        STATUS = 'REST_ENABLED',
                        ALIAS = L_REST_ALIAS,
                        CLIENT_ID = L_REST_CLIENT_ID,
                        CLIENT_SECRET = L_REST_CLIENT_SECRET
                    WHERE
                        ID = L_CURRENT_SCHEMA_ID;
                    COMMIT;

                    -- TODO: Add schema lockdown

                    REQUEST_SCHEMA_REGISTRATION( P_SCHEMA_ID => L_CURRENT_SCHEMA_ID );
                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_LOB.CREATETEMPORARY(
                            LOB_LOC => L_CURRENT_CREATION_ERROR,
                            CACHE => FALSE,
                            DUR => DBMS_LOB.CALL
                        );

                        DBMS_LOB.APPEND( L_CURRENT_CREATION_ERROR, DBMS_UTILITY.FORMAT_ERROR_STACK() );
                        DBMS_LOB.APPEND( L_CURRENT_CREATION_ERROR, CHR(10) );
                        DBMS_LOB.APPEND( L_CURRENT_CREATION_ERROR, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE() );

                        UPDATE
                            SCHEMAS
                        SET
                            CREATION_ERROR = L_CURRENT_CREATION_ERROR
                        WHERE
                            ID = L_CURRENT_SCHEMA_ID;
                        COMMIT;

                        DBMS_LOB.FREETEMPORARY( LOB_LOC => L_CURRENT_CREATION_ERROR );

                        L_SCHEMAS_ERRORS_COUNT := L_SCHEMAS_ERRORS_COUNT + 1;
                        DBMS_LOB.APPEND( L_SCHEMAS_ERRORS, CASE WHEN L_SCHEMAS_ERRORS_COUNT > 0 THEN CHR(10) END || 'An error occurred while creating schema "' || L_CURRENT_SCHEMA_NAME || '" with ID "' || L_CURRENT_SCHEMA_ID || '"' );
                END;
            END LOOP;

            IF L_SCHEMAS_ERRORS_COUNT > 0 THEN
                RAISE_APPLICATION_ERROR( -20000, L_SCHEMAS_ERRORS_COUNT || ' errors occurred while creating the schemas' );
            END IF;
        END;

        UPDATE
            SCHEMA_CREATION_JOBS
        SET
            STATUS = 'DONE'
        WHERE
            ID = P_SCHEMA_CREATION_JOB_ID;
        COMMIT;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR( -20000, 'Schema creation job does not exist' );
        WHEN OTHERS THEN
            IF L_ERROR IS NULL OR DBMS_LOB.GETLENGTH( L_ERROR ) = 0 THEN
                DBMS_LOB.CREATETEMPORARY(
                    LOB_LOC => L_ERROR,
                    CACHE => FALSE,
                    DUR => DBMS_LOB.CALL
                );
            ELSE
                DBMS_LOB.APPEND( L_ERROR, CHR(10) || CHR(10) || '---' || CHR(10) || CHR(10) );
            END IF;

            DBMS_LOB.APPEND( L_ERROR, DBMS_UTILITY.FORMAT_ERROR_STACK() );
            DBMS_LOB.APPEND( L_ERROR, CHR(10) );
            DBMS_LOB.APPEND( L_ERROR, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE() );

            IF L_SCHEMAS_ERRORS_COUNT > 0 THEN
                DBMS_LOB.APPEND( L_ERROR, CHR(10) );
                DBMS_LOB.APPEND( L_ERROR, L_SCHEMAS_ERRORS );
            END IF;
            DBMS_LOB.FREETEMPORARY( LOB_LOC => L_SCHEMAS_ERRORS );

            UPDATE
                SCHEMA_CREATION_JOBS
            SET
                ERROR = L_ERROR
            WHERE
                ID = P_SCHEMA_CREATION_JOB_ID;
            COMMIT;

            DBMS_LOB.FREETEMPORARY( LOB_LOC => L_ERROR );
    END PROCESS_SCHEMA_CREATION_JOB;
END SCHEMA_MANAGEMENT;
/

BEGIN
    DBMS_SCHEDULER.CREATE_PROGRAM (
        PROGRAM_NAME => 'PROCES_SCH_CREATION_JOB_PROG',
        PROGRAM_TYPE => 'STORED_PROCEDURE',
        PROGRAM_ACTION => 'SCHEMA_MANAGEMENT.PROCESS_SCHEMA_CREATION_JOB',
        NUMBER_OF_ARGUMENTS => 1,
        ENABLED => FALSE,
        COMMENTS => 'Processes a job to create schemas'
    );
    DBMS_SCHEDULER.DEFINE_PROGRAM_ARGUMENT (
        PROGRAM_NAME => 'PROCES_SCH_CREATION_JOB_PROG',
        ARGUMENT_NAME => 'P_SCHEMA_CREATION_JOB_ID',
        ARGUMENT_POSITION => 1,
        ARGUMENT_TYPE => 'VARCHAR2'
    );
    DBMS_SCHEDULER.ENABLE( NAME => 'PROCES_SCH_CREATION_JOB_PROG' );
    DBMS_SCHEDULER.CREATE_JOB(
        JOB_NAME => 'PROCESS_SCHEMA_CREATION_JOB',
        PROGRAM_NAME => 'PROCES_SCH_CREATION_JOB_PROG',
        ENABLED => FALSE
    );
END;
/

PROMPT INFO: Live SQL SCHEMAS Objects created
