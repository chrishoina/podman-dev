-- NOTE: This script is not intended to be used directly but through
--       install_pdb.sql

SET DEFINE '^'
SET ESCAPE OFF
SET ESCAPE '\'
SET VERIFY OFF
SET ECHO OFF

PROMPT INFO: Creating Live SQL METADATA Objects...
WHENEVER SQLERROR EXIT 1

-- TODO: Add a validate function
-- TODO: Execute the validate function and recomment either uninstalling or skip the installation
SET FEEDBACK ON
DECLARE
    L_RESULT NUMBER;
BEGIN
    SELECT
        1
    INTO
        L_RESULT
    FROM
        DUAL
    WHERE
        -- NOTE: Check if we're on an actual PDB
        SYS_CONTEXT( 'USERENV', 'CON_NAME' ) NOT IN ( 'CDB$ROOT', 'PDB$SEED' );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR( -20000, 'This script must be executed in a PDB' );
END;
/
-- SET FEEDBACK OFF

CREATE OR REPLACE TYPE VC2_TABLE_T AS TABLE OF VARCHAR2(32767 BYTE);
/

-- TODO: Check if this is really needed
CREATE OR REPLACE TYPE USER_SCHEMA_T IS OBJECT (
    ID NUMBER,
    NAME VARCHAR2(128),
    ALIAS VARCHAR2(128),
    DB_VERSION VARCHAR2(32),
    BASE_URL VARCHAR2(2048),
    CLIENT_ID VARCHAR2(128),
    CLIENT_SECRET VARCHAR2(128)
);
/

CREATE TABLE PARAMETERS(
    NAME VARCHAR2(128 BYTE) NOT NULL,
    CONSTRAINT PARAMETERS_PK PRIMARY KEY ( NAME ),
    -- NOTE: Limiting the parameter names to a bound regular expression of
    --       uppercase leters, digits and underscores starting by an uppercase
    --       letter. Not using star or plus on purpose so that no catastrophic
    --       backtrack is possible
    CONSTRAINT PARAMETERS_CHK1 CHECK ( REGEXP_LIKE( NAME, '\^[[:upper:]][[:upper:][:digit:]]{0,127}(_[[:upper:][:digit:]]{1,126}){0,63}$' ) ),
    VALUE VARCHAR2(4000 BYTE)
)
ENABLE PRIMARY KEY USING INDEX;

CREATE OR REPLACE FUNCTION IS_PARAMETER_NAME_VALID( P_NAME VARCHAR2 ) RETURN BOOLEAN IS
BEGIN
    RETURN REGEXP_LIKE( P_NAME, '\^[[:upper:]][[:upper:][:digit:]]{0,127}(_[[:upper:][:digit:]]{1,126}){0,63}$' );
END IS_PARAMETER_NAME_VALID;
/
CREATE OR REPLACE FUNCTION DOES_PARAMETER_EXIST( P_NAME VARCHAR2 ) RETURN BOOLEAN IS
    L_COUNT INTEGER;
BEGIN
    SELECT
        COUNT(1)
    INTO
        L_COUNT
    FROM
        PARAMETERS
    WHERE
        NAME = P_NAME;

    RETURN L_COUNT > 0;
END DOES_PARAMETER_EXIST;
/
CREATE OR REPLACE FUNCTION GET_PARAMETER( P_NAME VARCHAR2 ) RETURN VARCHAR2 IS
    L_VALUE PARAMETERS.VALUE%TYPE;
BEGIN
    SELECT
        VALUE
    INTO
        L_VALUE
    FROM
        PARAMETERS
    WHERE
        NAME = P_NAME;
    RETURN L_VALUE;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter "' || P_NAME || '" does not exist' );
END GET_PARAMETER;
/
CREATE OR REPLACE PROCEDURE SET_PARAMETER( P_NAME VARCHAR2, P_VALUE VARCHAR2 ) IS
BEGIN
    IF NOT IS_PARAMETER_NAME_VALID( P_NAME => P_NAME ) THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter name "' || P_NAME || '" is invalid.' );
    END IF;
    IF NVL( LENGTHB( P_VALUE ), 0 ) > 4000 THEN
        RAISE_APPLICATION_ERROR( -20000, 'Parameter value for "' || P_NAME || '" exceeds 4000 characters.' );
    END IF;

    MERGE INTO PARAMETERS
        USING DUAL
        ON ( PARAMETERS.NAME = P_NAME )
    WHEN MATCHED THEN
        UPDATE SET PARAMETERS.VALUE = P_VALUE
    WHEN NOT MATCHED THEN
        INSERT
            ( NAME, VALUE )
        VALUES
            ( P_NAME, P_VALUE );
END SET_PARAMETER;
/
CREATE OR REPLACE PROCEDURE REMOVE_PARAMETER( P_NAME VARCHAR2 ) IS
BEGIN
    DELETE FROM PARAMETERS WHERE NAME = P_NAME;
END REMOVE_PARAMETER;
/

CREATE OR REPLACE PACKAGE UTILITIES IS
    C_SLUG_STRING_LENGTH CONSTANT NUMBER := 57;
    C_SLUG_SUFFIX_LENGTH CONSTANT NUMBER := 6;
    -- NOTE: 1 is the dash craracter between both pieces
    C_SLUG_LENGTH CONSTANT NUMBER := C_SLUG_STRING_LENGTH + 1 + C_SLUG_SUFFIX_LENGTH;

    FUNCTION BOOLEAN_TO_YN( P_VALUE BOOLEAN ) RETURN VARCHAR2;
    FUNCTION YN_TO_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_CODE_LANGUAGE( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_CODE_LANGUAGE_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_DATABASE_VERSION( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_DATABASE_VERSION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_CONENT_ACTION( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_CONENT_ACTION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION IS_VALID_SLUG( P_VALUE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION IS_VALID_SLUG_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION GET_RANDOM_MIXED_ALNUM_STRING( P_LENGTH NUMBER ) RETURN VARCHAR2;
    FUNCTION STRING_TO_SLUG( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION STRING_TO_TABLE_SLUG( P_STRING VARCHAR2, P_SLUG_TABLE_NAME VARCHAR2, P_TRANSACTION_SLUG_TABLE_NAME VARCHAR2 DEFAULT NULL, P_MAX_ITERATIONS NUMBER DEFAULT NULL ) RETURN VARCHAR2;
    FUNCTION STRING_TO_ERROR_REASON( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION STRING_TO_BASE64( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION VC2_TABLE_TO_CLOB( P_VC2_TABLE VC2_TABLE_T ) RETURN CLOB;
    FUNCTION GET_SHARE_KEY RETURN VARCHAR2;
    FUNCTION GET_CLOB_SUBSTRING( P_CLOB IN OUT NOCOPY CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE BOOLEAN DEFAULT TRUE ) RETURN VARCHAR2;
    FUNCTION GET_CLOB_SUBSTRING_SQL( P_CLOB CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE_YN VARCHAR2 DEFAULT 'Y' ) RETURN VARCHAR2;
    FUNCTION STRING_TO_CONTAINS_QUERY( P_STRING VARCHAR2 ) RETURN VARCHAR2 DETERMINISTIC;
    FUNCTION HEX_ENCRYPT( P_STRING VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION HEX_DECRYPT( P_HEX_STRING VARCHAR2 ) RETURN VARCHAR2;
END UTILITIES;
/
CREATE OR REPLACE PACKAGE BODY UTILITIES IS
    FUNCTION BOOLEAN_TO_YN( P_VALUE BOOLEAN ) RETURN VARCHAR2 IS
        INVALID_VALUE EXCEPTION;
    BEGIN
        IF P_VALUE IS NULL THEN
            RAISE INVALID_VALUE;
        END IF;
        RETURN CASE WHEN P_VALUE THEN 'Y' ELSE 'N' END;
    END;
    FUNCTION YN_TO_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        RETURN P_VALUE = 'Y';
    END;

    FUNCTION IS_VALID_YN_BOOLEAN( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'Y', 'N' );
    END IS_VALID_YN_BOOLEAN;
    FUNCTION IS_VALID_YN_BOOLEAN_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_YN_BOOLEAN( P_VALUE ) );
    END IS_VALID_YN_BOOLEAN_YN;
    FUNCTION IS_VALID_CODE_LANGUAGE( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'PL_SQL', 'SQL', 'QUICK_SQL', 'JAVASCRIPT' );
    END IS_VALID_CODE_LANGUAGE;
    FUNCTION IS_VALID_CODE_LANGUAGE_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_CODE_LANGUAGE( P_VALUE ) );
    END IS_VALID_CODE_LANGUAGE_YN;
    FUNCTION IS_VALID_DATABASE_VERSION( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( '8', '9', '10', '11', '12', '18', '19', '21', '23' );
    END IS_VALID_DATABASE_VERSION;
    FUNCTION IS_VALID_DATABASE_VERSION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_DATABASE_VERSION( P_VALUE ) );
    END IS_VALID_DATABASE_VERSION_YN;
    FUNCTION IS_VALID_CONENT_ACTION( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        RETURN P_VALUE IN ( 'VIEW', 'LIKE', 'EXECUTE', 'FAVORITE' );
    END IS_VALID_CONENT_ACTION;
    FUNCTION IS_VALID_CONENT_ACTION_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_CONENT_ACTION( P_VALUE ) );
    END IS_VALID_CONENT_ACTION_YN;
    FUNCTION IS_VALID_SLUG( P_VALUE VARCHAR2 ) RETURN BOOLEAN IS
    BEGIN
        IF P_VALUE IS NULL THEN
            RETURN FALSE;
        END IF;
        /*
         * NOTE: Starts with a mixed alpha-numeric characters (1 up to 57)
         *       followed by up to 28 (57 - 1/2) blocks of at least 2 characters including
         *       a leading dash, followed by a dash an a mixed-case
         *       alpha-numeric string of 6 digits. Making a minimum string of 64
         *       characters
         */
        -- IMPORTANT: When modifying this REGEXP nake sure to change the check
        --            constraints in TUTORIALS and SCRIPTS
        RETURN LENGTH( P_VALUE ) BETWEEN 6 AND 64 AND REGEXP_LIKE( P_VALUE, '\^[a-zA-Z0-9]{1,' || C_SLUG_STRING_LENGTH || '}([-][a-zA-Z0-9]{1,' || C_SLUG_STRING_LENGTH - 2 || '}){0,' || FLOOR( ( C_SLUG_STRING_LENGTH - 1 ) / 2 ) || '}[-][a-zA-Z0-9]{' || C_SLUG_SUFFIX_LENGTH || '}$' );
    END IS_VALID_SLUG;
    FUNCTION IS_VALID_SLUG_YN( P_VALUE VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN BOOLEAN_TO_YN( IS_VALID_SLUG( P_VALUE ) );
    END IS_VALID_SLUG_YN;
    FUNCTION GET_RANDOM_MIXED_ALNUM_STRING( P_LENGTH NUMBER ) RETURN VARCHAR2 IS
        C_ALPHABET CONSTANT VARCHAR2(62 BYTE) := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        L_RESULT VARCHAR2(32767 BYTE);
    BEGIN
        IF P_LENGTH <= 0 THEN
            RAISE_APPLICATION_ERROR( -20000, 'Invalid string length. Provide a number between 1 and 32767' );
        END IF;
        FOR I IN 1 .. P_LENGTH LOOP
            L_RESULT := L_RESULT || SUBSTR( C_ALPHABET, DBMS_RANDOM.VALUE( LOW => 1, HIGH => LENGTH( C_ALPHABET ) ), 1 );
        END LOOP;
        RETURN L_RESULT;
    END GET_RANDOM_MIXED_ALNUM_STRING;
    FUNCTION STRING_TO_SLUG_STRING( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        L_SLUG_STRING VARCHAR2( C_SLUG_STRING_LENGTH BYTE ) := LOWER( TRIM( SUBSTRB( P_STRING, 1, C_SLUG_STRING_LENGTH ) ) );
    BEGIN
        -- NOTE: Replace non-alpha characters with dashes
        L_SLUG_STRING := REGEXP_REPLACE( L_SLUG_STRING, '[\^a-z0-9-]', '-' );
        -- NOTE: Replace repeated dashes with a single dash
        L_SLUG_STRING := REGEXP_REPLACE( L_SLUG_STRING, '[-]{2,' || C_SLUG_STRING_LENGTH || '}', '-' );
        L_SLUG_STRING := TRIM( BOTH '-' FROM L_SLUG_STRING );

        /*
         * NOTE: This will happen if the string which is being used is comprised
         *       only of non-english characters, think Japanese, Russian,
         *       Chinese, Arabic, and others.
         *
         *       We reviewed UTL_I18N transliteration capabilities but we are
         *       required to know the type of transliteration so we decided to
         *       use a mixed-case random string. See the note on GET_SLUG_SUFFIX
         *       for the reason for mixed-case
         *
         *       We decided on 10 characteds because that's the lenght of our
         *       share keys.
         */
        IF NVL( LENGTH( L_SLUG_STRING ), 0 ) = 0 THEN
            L_SLUG_STRING := GET_RANDOM_MIXED_ALNUM_STRING( P_LENGTH => 10 );
        END IF;

        RETURN L_SLUG_STRING;
    END STRING_TO_SLUG_STRING;
    FUNCTION GET_SLUG_SUFFIX RETURN VARCHAR2 IS
    BEGIN
        /*
         * NOTE: We decided to use 6 mixed-case alpha-numeric strings because
         *       production data importing had collisions with slugs because the
         *       script's title uniqueness is given by the user and the title,
         *       however, since we want scripts to be accessible via a slug, we
         *       can't expose the user's e-mail in the URL of the script.
         *
         *       After researching on the impact of mixed case on SEO we
         *       discovered that youtube's embedding URLs refer to their
         *       canonical URL as the full youtube with the query parameter
         *       watch, whose value consists of 12 random characters from an
         *       alphabet that includes underscore.
         *
         *       Also, several authors discard the use of mixed-case strings as
         *       a hindering factor for SEO
         *
         *       The alphabet for these random strings is 62 characters and we
         *       picked the length of 6 characters because the number of
         *       possible combinations would be 62^6 (56,800,235,584). Which is
         *       a big number for collisions considering current production
         *       dataset holds only 2.2M of records in a span of 10 years.
         */
        RETURN '-' || GET_RANDOM_MIXED_ALNUM_STRING( P_LENGTH => C_SLUG_SUFFIX_LENGTH );
    END GET_SLUG_SUFFIX;
    FUNCTION STRING_TO_SLUG( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN STRING_TO_SLUG_STRING( P_STRING ) || GET_SLUG_SUFFIX();
    END STRING_TO_SLUG;
    FUNCTION STRING_TO_TABLE_SLUG( P_STRING VARCHAR2, P_SLUG_TABLE_NAME VARCHAR2, P_TRANSACTION_SLUG_TABLE_NAME VARCHAR2 DEFAULT NULL, P_MAX_ITERATIONS NUMBER DEFAULT NULL ) RETURN VARCHAR2 IS
        C_MAX_ITERATIONS CONSTANT NUMBER := NVL( P_MAX_ITERATIONS, 10 );
        C_SLUG_TABLE_NAME CONSTANT VARCHAR2(128 BYTE) := DBMS_ASSERT.ENQUOTE_NAME(
            STR => DBMS_ASSERT.SQL_OBJECT_NAME( P_SLUG_TABLE_NAME ),
            CAPITALIZE => FALSE
        );
        C_TRANSACTION_SLUG_TABLE_NAME CONSTANT VARCHAR2(128 BYTE) := DBMS_ASSERT.ENQUOTE_NAME(
            STR => DBMS_ASSERT.SQL_OBJECT_NAME( NVL( P_TRANSACTION_SLUG_TABLE_NAME, 'TRANSACTION_' || P_SLUG_TABLE_NAME || '_SLUGS' ) ),
            CAPITALIZE => FALSE
        );

        L_ITERATIONS NUMBER := 0;
        L_COUNT NUMBER;

        L_DOES_SLUG_EXISTS BOOLEAN := FALSE;
        L_SLUG VARCHAR2(C_SLUG_LENGTH BYTE);
        L_SLUG_STRING VARCHAR2(C_SLUG_STRING_LENGTH BYTE) := STRING_TO_SLUG_STRING( P_STRING => P_STRING );

        FUNCTION DOES_SLUG_EXISTS( P_SLUG VARCHAR2 ) RETURN BOOLEAN IS
            PRAGMA AUTONOMOUS_TRANSACTION;
            L_COUNT NUMBER;
        BEGIN
            EXECUTE IMMEDIATE 'SELECT COUNT(1) FROM ' || C_SLUG_TABLE_NAME || ' WHERE SLUG = :1' INTO L_COUNT USING P_SLUG;
            RETURN L_COUNT >= 1;
        END DOES_SLUG_EXISTS;
    BEGIN
        LOOP
            L_ITERATIONS := L_ITERATIONS + 1;
            L_SLUG := L_SLUG_STRING || GET_SLUG_SUFFIX();
            L_DOES_SLUG_EXISTS := DOES_SLUG_EXISTS( P_SLUG => L_SLUG );
            IF NOT L_DOES_SLUG_EXISTS THEN
                EXECUTE IMMEDIATE 'SELECT COUNT(1) FROM ' || C_TRANSACTION_SLUG_TABLE_NAME || ' WHERE SLUG = :1' INTO L_COUNT USING L_SLUG;
                L_DOES_SLUG_EXISTS := L_COUNT >= 1;
            END IF;
            EXIT WHEN NOT L_DOES_SLUG_EXISTS;
            IF L_ITERATIONS >= C_MAX_ITERATIONS THEN
                RAISE_APPLICATION_ERROR( -20000, 'Could not obtain a unique slug for table ' || P_SLUG_TABLE_NAME || ' after ' || C_MAX_ITERATIONS || ' iterations' );
            END IF;
        END LOOP;
        EXECUTE IMMEDIATE 'INSERT INTO ' || C_TRANSACTION_SLUG_TABLE_NAME || '( SLUG ) VALUES ( :1 )' USING L_SLUG;
        RETURN L_SLUG;
    END STRING_TO_TABLE_SLUG;
    FUNCTION STRING_TO_ERROR_REASON( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        C_ERROR_REASON_PREFIX CONSTANT VARCHAR2(40) := q'[error="body"; error_description*=UTF-8'']';
        -- NOTE: Escaping consumes at most 3 characters per character. Minus 40 of the prefix. Floored. 32K / 3 = 10.9K
        C_STRING_MAX_LENGTH CONSTANT NUMBER := 10900;

        L_STRING VARCHAR2( C_STRING_MAX_LENGTH );

        INVALID_STRING EXCEPTION;
    BEGIN
        IF P_STRING IS NULL THEN
            RAISE INVALID_STRING;
        END IF;
        IF NVL( LENGTH( P_STRING ), 0 ) > C_STRING_MAX_LENGTH THEN
            -- NOTE: Subtracting 3 because of the ellipsis
            L_STRING := TRIM( SUBSTR( 1, C_STRING_MAX_LENGTH - 3 ) ) || '...';
        ELSE
            L_STRING := P_STRING;
        END IF;

        RETURN 'error="body"; error_description*=UTF-8''''' || SYS.UTL_URL.ESCAPE(
            URL => L_STRING,
            ESCAPE_RESERVED_CHARS => TRUE,
            URL_CHARSET => 'AL32UTF8'
        );
    END STRING_TO_ERROR_REASON;

    FUNCTION STRING_TO_BASE64( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        RETURN UTL_RAW.CAST_TO_VARCHAR2( UTL_ENCODE.BASE64_ENCODE( UTL_RAW.CAST_TO_RAW( P_STRING ) ) );
    END STRING_TO_BASE64;

    FUNCTION VC2_TABLE_TO_CLOB( P_VC2_TABLE VC2_TABLE_T ) RETURN CLOB IS
        L_CLOB CLOB;
        L_SIZE NUMBER;
    BEGIN
        SYS.DBMS_LOB.CREATETEMPORARY( LOB_LOC => L_CLOB, CACHE => TRUE, DUR => SYS.DBMS_LOB.SESSION );

        FOR I IN 1 .. P_VC2_TABLE.COUNT LOOP
            L_SIZE := NVL( LENGTHB( P_VC2_TABLE( I ) ), 0 );
            SYS.DBMS_LOB.WRITEAPPEND( LOB_LOC => L_CLOB, AMOUNT => L_SIZE, BUFFER => P_VC2_TABLE( I ) );
        END LOOP;

        RETURN L_CLOB;
    EXCEPTION
        WHEN OTHERS THEN
            IF SYS.DBMS_LOB.ISTEMPORARY( LOB_LOC => L_CLOB ) = 1 THEN
                SYS.DBMS_LOB.FREETEMPORARY( LOB_LOC => L_CLOB );
            END IF;
            RAISE;
    END VC2_TABLE_TO_CLOB;

    FUNCTION GET_SHARE_KEY RETURN VARCHAR2 IS
    BEGIN
        RETURN GET_RANDOM_MIXED_ALNUM_STRING( P_LENGTH => 10 );
    END GET_SHARE_KEY;

    FUNCTION GET_CLOB_SUBSTRING( P_CLOB IN OUT NOCOPY CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE BOOLEAN DEFAULT TRUE ) RETURN VARCHAR2 IS
        L_CLOB_LENGTH NUMBER := NVL( DBMS_LOB.GETLENGTH( P_CLOB ), 0 );
        L_RESULT VARCHAR2(32767);

        INVALID_PARAMETER EXCEPTION;
    BEGIN
        IF
            P_LENGTH < 1
            OR P_LENGTH > 32767
            OR P_START < 1
            OR P_START > P_LENGTH
            OR (
                P_ELLIPSIZE
                AND (
                    (
                        P_START = 1
                        -- NOTE: at least 1 character besides the ellipsis
                        AND P_LENGTH < 4
                    )
                    OR (
                        P_START > 1
                        -- NOTE: at least 1 character besides the ellipsis
                        AND P_LENGTH < 7
                    )
                )
            )
        THEN
            RAISE INVALID_PARAMETER;
        END IF;

        L_RESULT := DBMS_LOB.SUBSTR( LOB_LOC => P_CLOB, AMOUNT => P_LENGTH, OFFSET => P_START );

        IF NOT P_ELLIPSIZE THEN
            RETURN L_RESULT;
        END IF;

        IF P_START > 1 THEN
            L_RESULT := '...' || TRIM( SUBSTR( L_RESULT, 1, LENGTH( L_RESULT ) - 3 ) );
        END IF;

        -- NOTE: Only ellipzise from the end if it is not the actual end of the CLOB
        IF P_START + P_LENGTH < L_CLOB_LENGTH THEN
            L_RESULT := TRIM( SUBSTR( L_RESULT, 1, LENGTH( L_RESULT ) - 3 ) ) || '...';
        END IF;

        RETURN L_RESULT;
    END GET_CLOB_SUBSTRING;
    -- NOTE: Not using NOCOPY because SQL prevents the use of out parameters
    FUNCTION GET_CLOB_SUBSTRING_SQL( P_CLOB CLOB, P_LENGTH NUMBER DEFAULT 4000, P_START NUMBER DEFAULT 1, P_ELLIPSIZE_YN VARCHAR2 DEFAULT 'Y' ) RETURN VARCHAR2 IS
        L_CLOB CLOB := P_CLOB;
    BEGIN
        RETURN GET_CLOB_SUBSTRING(
            P_CLOB => L_CLOB,
            P_LENGTH => P_LENGTH,
            P_START => P_START,
            P_ELLIPSIZE => P_ELLIPSIZE_YN = 'Y'
        );
    END GET_CLOB_SUBSTRING_SQL;

    FUNCTION STRING_TO_CONTAINS_QUERY( P_STRING VARCHAR2 ) RETURN VARCHAR2 DETERMINISTIC IS
    BEGIN
        -- SEE: https://docs.oracle.com/en/database/oracle/oracle-database/19/ccref/oracle-text-CONTAINS-query-operators.html#CCREF-GUID-5BA618D7-45DA-4253-BB0D-313970EA7C5D
        RETURN 'FUZZY({' || REPLACE( P_STRING, '}', '\}' ) || '}, 30, 200)';
    END STRING_TO_CONTAINS_QUERY;

    FUNCTION HEX_ENCRYPT( P_STRING VARCHAR2 ) RETURN VARCHAR2 IS
        L_ENCRYPTION_KEY RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_KEY' ) );
        L_ENCRYPTION_IV RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_IV' ) );
    BEGIN
        RETURN RAWTOHEX( DBMS_CRYPTO.ENCRYPT(
            SRC => UTL_I18N.STRING_TO_RAW( DATA => P_STRING ),
            TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
            KEY => L_ENCRYPTION_KEY,
            IV => L_ENCRYPTION_IV
        ) );
    END HEX_ENCRYPT;

    FUNCTION HEX_DECRYPT( P_HEX_STRING VARCHAR2 ) RETURN VARCHAR2 IS
    L_ENCRYPTION_KEY RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_KEY' ) );
        L_ENCRYPTION_IV RAW(2000) := HEXTORAW( GET_PARAMETER( 'ENCRYPTION_IV' ) );
    BEGIN
        RETURN UTL_I18N.RAW_TO_CHAR( DATA => DBMS_CRYPTO.DECRYPT(
            SRC => HEXTORAW( P_HEX_STRING ),
            TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
            KEY => L_ENCRYPTION_KEY,
            IV => L_ENCRYPTION_IV
        ) );
    END HEX_DECRYPT;
END UTILITIES;
/

CREATE TABLE ROLES (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT ROLES_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(255 BYTE) NOT NULL,
    SEQUENCE NUMBER NOT NULL,
    CONSTRAINT ROLES_UQ1 UNIQUE ( SEQUENCE ) USING INDEX ( CREATE UNIQUE INDEX ROLES_IDX1 ON ROLES( SEQUENCE ) ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
@@../../utilities/create_before_update_trigger.sql ROLES
CREATE TABLE USERS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT USERS_PK PRIMARY KEY ( ID ),
    EMAIL VARCHAR2(320 BYTE) NOT NULL,
    CONSTRAINT USERS_UQ1 UNIQUE ( EMAIL ) USING INDEX ( CREATE UNIQUE INDEX USERS_IDX1 ON USERS( EMAIL ) ),
    DISPLAY_NAME VARCHAR2(128 BYTE),
    ROLE_ID NUMBER NOT NULL,
    CONSTRAINT USERS_ROLES_FK FOREIGN KEY ( ROLE_ID ) REFERENCES ROLES( ID ),
    DISCLAIMER_ACCEPTED_ON TIMESTAMP (6) WITH TIME ZONE,
    IS_BLOCKED VARCHAR2(1) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT USERS_CHK1 CHECK ( IS_BLOCKED IN ( 'Y', 'N' ) ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE,
    -- SECTION: LIVESQL-612
    LAST_SESSION_EXPIRED_ON TIMESTAMP (6) WITH TIME ZONE
    -- !SECTION: LIVESQL-612 
)
ENABLE PRIMARY KEY USING INDEX;
CREATE OR REPLACE TRIGGER USERS_BI BEFORE INSERT ON USERS FOR EACH ROW
BEGIN
    :NEW.EMAIL := UPPER( :NEW.EMAIL );
END;
/
@@../../utilities/create_before_update_trigger.sql USERS
-- NOTE: For some reason old Live SQL likes to use 32 digit IDs
CREATE TABLE DATABASES (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT DATABASES_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(128 BYTE) NOT NULL,
    -- TYPE VARCHAR2(64 BYTE) DEFAULT ON NULL 'ORACLE' NOT NULL,
    -- CONSTRAINT DATABASES_CHK2 CHECK ( TYPE IN 'ORACLE' ),
    -- NOTE: VERSION should be in one of the following formats to be able to be
    -- sorted: 0 | 0.0 | 0.0.0
    VERSION VARCHAR2(32 BYTE) NOT NULL,
    CONSTRAINT DATABASES_CHK1 CHECK ( VERSION IN ( '19', '21', '23' ) ),
    BASE_URL VARCHAR2(2048 BYTE) NOT NULL,
    ADMIN_SCHEMA_NAME VARCHAR2(30 BYTE) NOT NULL,
    ADMIN_SCHEMA_ALIAS VARCHAR2(255 BYTE) NOT NULL,
    -- NOTE: Client IDs are 32 characters and 96 when HEX encrypted
    ADMIN_CLIENT_ID VARCHAR2(96 BYTE) NOT NULL,
    -- NOTE: Client secrets are 32 characters and 96 when HEX encrypted
    ADMIN_CLIENT_SECRET VARCHAR2(96 BYTE) NOT NULL,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
@@../../utilities/create_before_update_trigger.sql DATABASES
/*
 * TODO: Check how to handle schema deletion, should we add a trigger that
 *       creates a JOB in the schemas database? Or should we monitor orphan
 *       schemas
 */
CREATE TABLE SCHEMAS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCHEMAS_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(30 BYTE) NOT NULL,
    ASSIGNED_TO VARCHAR2(320 BYTE),
    CONSTRAINT SCHEMAS_USERS_FK FOREIGN KEY ( ASSIGNED_TO ) REFERENCES USERS( EMAIL ),
    DATABASE_ID NUMBER NOT NULL,
    DATABASE_SCHEMA_ID NUMBER,
    DATABASE_SCHEMA_CREATN_JOB_ID NUMBER,
    CONSTRAINT SCHEMAS_DATABASES_FK FOREIGN KEY ( DATABASE_ID ) REFERENCES DATABASES( ID ),
    CONSTRAINT SCHEMAS_UQ1 UNIQUE ( NAME, DATABASE_ID ) USING INDEX ( CREATE UNIQUE INDEX SCHEMAS_IDX1 ON SCHEMAS( NAME, DATABASE_ID ) ),
    ALIAS VARCHAR2(255 BYTE) NOT NULL,
    -- NOTE: Client IDs are 32 characters and 96 when HEX encrypted
    CLIENT_ID VARCHAR2(96 BYTE) NOT NULL,
    -- NOTE: Client secrets are 32 characters and 96 when HEX encrypted
    CLIENT_SECRET VARCHAR2(96 BYTE) NOT NULL,
    STATUS VARCHAR2(32 BYTE) DEFAULT ON NULL 'AVAILABLE' NOT NULL,
    CONSTRAINT SCHEMAS_CHK1 CHECK ( STATUS IN ( 'AVAILABLE', 'ASSIGNED', 'DROPPING', 'DROPPED' ) ),
    IS_READ_ONLY VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT SCHEMAS_CHK2 CHECK ( IS_READ_ONLY IN ( 'Y', 'N' ) ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;

CREATE UNIQUE INDEX SCHEMAS_IDX2 ON SCHEMAS(
    CASE WHEN ASSIGNED_TO IS NOT NULL THEN
        STATUS
    END,
    CASE WHEN ASSIGNED_TO IS NOT NULL THEN
        ASSIGNED_TO
    END,
    CASE WHEN ASSIGNED_TO IS NOT NULL THEN
        DATABASE_ID
    END
);
CREATE UNIQUE INDEX SCHEMAS_IDX3 ON SCHEMAS(
    CASE WHEN ASSIGNED_TO IS NOT NULL THEN
        ASSIGNED_TO
    END,
    CASE WHEN ASSIGNED_TO IS NOT NULL THEN
        DATABASE_ID
    END
);
@@../../utilities/create_before_update_trigger.sql SCHEMAS
CREATE TABLE STATEMENTS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT STATEMENTS_PK PRIMARY KEY ( ID ),
    CODE_LANGUAGE VARCHAR2(32 BYTE) DEFAULT ON NULL 'PL_SQL' NOT NULL,
    CONSTRAINT STATEMENTS_CHK1 CHECK ( CODE_LANGUAGE IN ( 'PL_SQL', 'QUICK_SQL', 'JAVASCRIPT','SQL_PLUS' ) ),
    CONTENT CLOB NOT NULL,
    -- NOTE: This is a BLOB because its content uses about half of the space
    --       this way versus using a CLOB. Besides, when the constraint is
    --       applied, the JSON properties can also be accessed in the query
    RESULT BLOB NOT NULL,
    CONSTRAINT STATEMENTS_CHK2 CHECK ( RESULT IS JSON ),
    CONSTRAINT STATEMENTS_CHK3 CHECK (
        (
            CODE_LANGUAGE IN ( 'PL_SQL', 'JAVASCRIPT', 'SQL_PLUS' )
            AND JSON_EXISTS ( RESULT, '$.statementPos' )
            AND JSON_EXISTS ( RESULT, '$.response' )
            AND JSON_VALUE(RESULT, '$.statementId') IS NOT NULL
            AND JSON_VALUE(RESULT, '$.statementText') IS NOT NULL
            AND JSON_VALUE(RESULT, '$.statementType') IS NOT NULL
            AND JSON_VALUE(RESULT, '$.result') IS NOT NULL
            AND JSON_VALUE(RESULT, '$.statementTimestamp') IS NOT NULL
        )
        OR
        (
            CODE_LANGUAGE = 'QUICK_SQL'
            AND JSON_EXISTS ( RESULT, '$.env' )
            AND JSON_EXISTS ( RESULT, '$.items' )
        )
    ),
    SCHEMA_ID NUMBER NOT NULL,
    CONSTRAINT STATEMENTS_SCHEMAS_FK FOREIGN KEY ( SCHEMA_ID ) REFERENCES SCHEMAS( ID ) ON DELETE CASCADE,
    CREATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT STATEMENTS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX STATEMENTS_IDX1 ON STATEMENTS( CONTENT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX STATEMENTS_IDX2 ON STATEMENTS( RESULT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE TABLE CONTENT_CATEGORIES (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT CONTENT_CATEGORIES_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(255),
    CONSTRAINT CONTENT_CATEGORIES_UQ1 UNIQUE ( NAME ) USING INDEX ( CREATE UNIQUE INDEX CONTENT_CATEGORIES_IDX1 ON CONTENT_CATEGORIES( NAME ) ),
    DESCRIPTION CLOB,
    CONTENT_CATEGORY_ID NUMBER,
    CONSTRAINT CONTENT_CATEGORIES_CNT_CATS_FK FOREIGN KEY ( CONTENT_CATEGORY_ID ) REFERENCES CONTENT_CATEGORIES( ID ),
    LEGACY_ID NUMBER,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
@@../../utilities/create_before_update_trigger.sql CONTENT_CATEGORIES
/*
 * TODO: Create a materialized view that refreshes on commit with an XML column
 *       with has a Text index that includes all searchable columns of TUTORIALS
 *       and TUTORIALS_STEPS so that it is possible to search in the full
 *       tutorial.
 *
 *       See: https://stackoverflow.com/a/19483275 and
 *       https://connor-mcdonald.com/2022/01/31/silent-data-corruption-constraints-spanning-multiple-rows/
 */
CREATE TABLE TUTORIALS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT TUTORIALS_PK PRIMARY KEY ( ID ),
    TITLE VARCHAR2(255 BYTE) NOT NULL,
    DESCRIPTION CLOB,
    MINIMUM_DATABASE_VERSION VARCHAR2(32 BYTE),
    CONSTRAINT TUTORIALS_CHK1 CHECK ( MINIMUM_DATABASE_VERSION IN ( '8', '9', '10', '11', '12', '18', '19', '21', '23' ) ),
    SETUP_DESCRIPTION CLOB,
    SETUP_CODE_LANGUAGE VARCHAR2(255),
    CONSTRAINT TUTORIALS_CHK2 CHECK ( SETUP_CODE_LANGUAGE IN ( 'PL_SQL', 'SQL', 'QUICK_SQL', 'JAVASCRIPT' ) ),
    SETUP_CODE CLOB,
    CONTENT_CATEGORY_ID NUMBER,
    CONSTRAINT TUTORIALS_CONTENT_CATEGORIES_FK FOREIGN KEY ( CONTENT_CATEGORY_ID ) REFERENCES CONTENT_CATEGORIES( ID ),
    -- NOTE: New share keys are 10 characters, however the old field was 512
    SHARE_KEY VARCHAR2(512 BYTE),
    TAGS VARCHAR2(4000 BYTE),
    SLUG VARCHAR2( 64 BYTE ) NOT NULL,
    CONSTRAINT TUTORIALS_UQ1 UNIQUE ( SLUG ) USING INDEX ( CREATE UNIQUE INDEX TUTORIALS_IDX7 ON TUTORIALS( SLUG ) ),
    /*
     * NOTE: The column length limit will take care of rejecting longer strings.
     *
     *       Check constraints cannot call user-defined functions so the REGEXP
     *       needs to be a literal here
     *
     *       See UTILITIES.IS_VALID_SLUG for the explanation for the REGEXP
     */
    -- IMPORTANT: If altering this REGEXP, make sure to propagate the change to
    --            the other tables with slugs and to the UTILITIES.IS_VALID_SLUG
    --            package
    CONSTRAINT TUTORIALS_CHK5 CHECK ( REGEXP_LIKE( SLUG, '\^[a-zA-Z0-9]{1,57}([-][a-zA-Z0-9]{1,55}){0,28}[-][a-zA-Z0-9]{6}$' ) ),
    IS_PUBLISHED VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT TUTORIALS_CHK3 CHECK ( IS_PUBLISHED IN ( 'Y', 'N' ) ),
    IS_FEATURED VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT TUTORIALS_CHK4 CHECK ( IS_FEATURED IN ( 'Y', 'N' ) ),
    LEGACY_ID NUMBER,
    -- NOTE: Will contain the file name that was used to access the tutorials
    LEGACY_FILE_NAME VARCHAR2(4000 BYTE),
    CREATED_BY VARCHAR2(320 BYTE),
    -- NOTE: Tutorials are removed when the creator is deleted
    CONSTRAINT TUTORIALS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE CASCADE,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT TUTORIALS_USERS_FK2 FOREIGN KEY ( UPDATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX TUTORIALS_IDX1 ON TUTORIALS( IS_PUBLISHED, IS_FEATURED, CREATED_BY );
CREATE INDEX TUTORIALS_IDX2 ON TUTORIALS( DESCRIPTION )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX TUTORIALS_IDX3 ON TUTORIALS( SETUP_DESCRIPTION )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX TUTORIALS_IDX4 ON TUTORIALS( SETUP_CODE )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX TUTORIALS_IDX5 ON TUTORIALS( TITLE )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX TUTORIALS_IDX6 ON TUTORIALS( TAGS )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE GLOBAL TEMPORARY TABLE TRANSACTION_TUTORIALS_SLUGS (
    SLUG VARCHAR2(64 BYTE)
) ON COMMIT DELETE ROWS;
CREATE OR REPLACE TRIGGER TUTORIALS_BIU BEFORE INSERT OR UPDATE ON TUTORIALS FOR EACH ROW
BEGIN
    IF INSERTING THEN
        :NEW.SLUG := UTILITIES.STRING_TO_TABLE_SLUG( P_STRING => :NEW.TITLE, P_SLUG_TABLE_NAME => 'TUTORIALS' );
    END IF;
    IF UPDATING THEN
        :NEW.SLUG := :OLD.SLUG;
    END IF;
END;
/
@@../../utilities/create_before_update_trigger.sql TUTORIALS
CREATE TABLE TUTORIALS_STEPS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT TUTORIALS_STEPS_PK PRIMARY KEY ( ID ),
    TUTORIAL_ID NUMBER,
    CONSTRAINT TUTORIALS_STEPS_TUTORIALS_FK FOREIGN KEY ( TUTORIAL_ID ) REFERENCES TUTORIALS( ID ) ON DELETE CASCADE,
    SEQUENCE NUMBER,
    CONSTRAINT TUTORIALS_STEPS_UQ1 UNIQUE ( TUTORIAL_ID, SEQUENCE ) DEFERRABLE INITIALLY DEFERRED USING INDEX ( CREATE INDEX TUTORIALS_STEPS_IDX1 ON TUTORIALS_STEPS( TUTORIAL_ID, SEQUENCE ) ),
    TITLE VARCHAR2(255 BYTE),
    CONTENT CLOB NOT NULL,
    LEGACY_ID NUMBER,
    FORMAT VARCHAR2(16 BYTE) DEFAULT ON NULL 'MARKDOWN',
    CONSTRAINT TUTORIALS_STEPS_CHK1 CHECK ( FORMAT IN ( 'MARKDOWN', 'HTML' ) ), 
    CREATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT TUTORIALS_STEPS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT TUTORIALS_STEPS_USERS_FK2 FOREIGN KEY ( UPDATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX TUTORIALS_STEPS_IDX2 ON TUTORIALS_STEPS( CONTENT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX TUTORIALS_STEPS_IDX3 ON TUTORIALS_STEPS( TITLE )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
@@../../utilities/create_before_update_trigger.sql TUTORIALS_STEPS
-- TODO: Decide what to do with user metrics when a user is deleted
CREATE TABLE TUTORIALS_METRICS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT TUTORIALS_METRICS_PK PRIMARY KEY ( ID ),
    TUTORIAL_ID NUMBER NOT NULL,
    CONSTRAINT TUTORIALS_METRICS_TUTORIALS_FK FOREIGN KEY ( TUTORIAL_ID ) REFERENCES TUTORIALS( ID ) ON DELETE CASCADE,
    ACTION VARCHAR2(255 BYTE) NOT NULL,
    CONSTRAINT TUTORIALS_METRICS_CHK1 CHECK ( ACTION IN ( 'VIEW', 'LIKE', 'EXECUTE', 'FAVORITE' ) ),
    CREATED_BY VARCHAR2(320 BYTE),
    -- NOTE: If a user is deleted, metris belonging to it are removed
    CONSTRAINT TUTORIALS_METRICS_USERS_FK FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE CASCADE,
    CONSTRAINT TUTORIALS_METRICS_CHK2 CHECK ( ACTION IN ( 'EXECUTE', 'VIEW' ) OR CREATED_BY IS NOT NULL ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL
)
ENABLE PRIMARY KEY USING INDEX;
CREATE UNIQUE INDEX TUTORIALS_METRICS_IDX1 ON TUTORIALS_METRICS(
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        ACTION
    END,
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        TUTORIAL_ID
    END,
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        CREATED_BY
    END
);
CREATE INDEX TUTORIALS_METRICS_IDX2 ON TUTORIALS_METRICS( CREATED_BY, CREATED_ON );
CREATE MATERIALIZED VIEW TUTORIALS_METRICS_MV
    REFRESH FORCE ON DEMAND
    START WITH SYSDATE
    NEXT (SYSDATE + 4/24 )
AS
    SELECT
        TUTORIAL_ID AS ID,
        SUM( CASE WHEN ACTION = 'VIEW' THEN 1 ELSE 0 END ) AS VIEWS,
        SUM( CASE WHEN ACTION = 'LIKE' THEN 1 ELSE 0 END ) AS LIKES,
        SUM( CASE WHEN ACTION = 'FAVORITE' THEN 1 ELSE 0 END ) AS FAVORITES,
        SUM( CASE WHEN ACTION = 'EXECUTE' THEN 1 ELSE 0 END ) AS EXECUTIONS
    FROM
        TUTORIALS_METRICS
    GROUP BY
        TUTORIAL_ID;
ALTER MATERIALIZED VIEW TUTORIALS_METRICS_MV ADD CONSTRAINT TUTORIALS_METRICS_MV_PK PRIMARY KEY ( ID );
CREATE OR REPLACE VIEW TUTORIALS_USER_METRICS (
    ID,
    VIEWS,
    EXECUTIONS,
    LAST_VIEWED_ON,
    LAST_EXECUTED_ON,
    LIKED_ON,
    FAVORITED_ON,
    CREATED_BY,
    CONSTRAINT TUTORIALS_USER_METRICS_PK PRIMARY KEY ( CREATED_BY, ID ) RELY DISABLE NOVALIDATE
) AS
SELECT
    TUTORIAL_ID AS ID,
    VIEWS_COUNT AS VIEWS,
    EXECUTIONS_COUNT AS EXECUTIONS,
    VIEWS_LAST_TIMESTAMP AS LAST_VIEWED_ON,
    EXECUTIONS_LAST_TIMESTAMP AS LAST_EXECUTED_ON,
    LIKE_LAST_TIMESTAMP AS LIKED_ON,
    FAVORITE_LAST_TIMESTAMP AS FAVORITED_ON,
    CREATED_BY
FROM
    (
        -- NOTE: If we don't do this as a subquery without the ID column, the
        --       pivot takes that column into account, and if it is unique, then
        --       you will get a lot of unwanted rows
        SELECT
            TUTORIAL_ID,
            ACTION,
            CREATED_BY,
            CREATED_ON
        FROM
            TUTORIALS_METRICS
        WHERE
            CREATED_BY IS NOT NULL
    )
PIVOT (
    MAX( CREATED_ON ) AS "LAST_TIMESTAMP",
    COUNT( 1 ) AS "COUNT"
    FOR ACTION IN (
        'VIEW' AS VIEWS,
        'LIKE' AS "LIKE",
        'FAVORITE' AS FAVORITE,
        'EXECUTE' AS EXECUTIONS
    )
);
-- SELECT * FROM TUTORIALS_USER_METRICS
/*
 * TODO: Create a materialized view that refreshes on commit with an XML column
 *       with has a Text index that includes all searchable columns of SCRIPTS
 *       and SCRIPTS_STEPS so that it is possible to search in the full
 *       tutorial.
 *
 *       See: https://stackoverflow.com/a/19483275 and
 *       https://connor-mcdonald.com/2022/01/31/silent-data-corruption-constraints-spanning-multiple-rows/
 */
CREATE TABLE SCRIPTS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCRIPTS_PK PRIMARY KEY ( ID ),
    TITLE VARCHAR2(255 BYTE) NOT NULL,
    DESCRIPTION CLOB,
    MINIMUM_DATABASE_VERSION VARCHAR2(32 BYTE),
    CONSTRAINT SCRIPTS_CHK1 CHECK ( MINIMUM_DATABASE_VERSION IN ( '8', '9', '10', '11', '12', '18', '19', '21', '23' ) ),
    TAGS VARCHAR2(4000 BYTE),
    SHARE_KEY VARCHAR2(512 BYTE),
    CONTENT_CATEGORY_ID NUMBER,
    CONSTRAINT SCRIPTS_CONTENT_CATEGORIES_FK FOREIGN KEY ( CONTENT_CATEGORY_ID ) REFERENCES CONTENT_CATEGORIES( ID ),
    SLUG VARCHAR2(64 BYTE) NOT NULL,
    CONSTRAINT SCRIPTS_UQ1 UNIQUE ( SLUG ) USING INDEX ( CREATE UNIQUE INDEX SCRIPTS_IDX5 ON SCRIPTS( SLUG ) ),
    /*
     * NOTE: The column length limit will take care of rejecting longer strings.
     *
     *       Check constraints cannot call user-defined functions so the REGEXP
     *       needs to be a literal here
     *
     *       See UTILITIES.IS_VALID_SLUG for the explanation for the REGEXP
     */
    -- IMPORTANT: If altering this REGEXP, make sure to propagate the change to
    --            the other tables with slugs and to the UTILITIES.IS_VALID_SLUG
    --            package
    CONSTRAINT SCRIPTS_CHK4 CHECK ( REGEXP_LIKE( SLUG, '\^[a-zA-Z0-9]{1,57}([-][a-zA-Z0-9]{1,55}){0,28}[-][a-zA-Z0-9]{6}$' ) ),
    IS_PUBLISHED VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT SCRIPTS_CHK2 CHECK ( IS_PUBLISHED IN ( 'Y', 'N' ) ),
    IS_FEATURED VARCHAR2(1 BYTE) DEFAULT ON NULL 'N' NOT NULL,
    CONSTRAINT SCRIPTS_CHK3 CHECK ( IS_FEATURED IN ( 'Y', 'N' ) ),
    LEGACY_ID NUMBER,
    LEGACY_FILE_NAME VARCHAR2(4000 BYTE),
    -- CONSTRAINT SCRIPTS_UQ2 UNIQUE ( LEGACY_FILE_NAME ) USING INDEX ( CREATE UNIQUE INDEX SCRIPTS_IDX6 ON SCRIPTS( LEGACY_FILE_NAME ) ),
    CREATED_BY VARCHAR2(320 BYTE),
    -- NOTE: Remove scripts when the creator is deleted
    CONSTRAINT SCRIPTS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE CASCADE,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT SCRIPTS_USERS_FK2 FOREIGN KEY ( UPDATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX SCRIPTS_IDX1 ON SCRIPTS( IS_PUBLISHED, IS_FEATURED, CREATED_BY );
CREATE INDEX SCRIPTS_IDX2 ON SCRIPTS( DESCRIPTION )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX SCRIPTS_IDX3 ON SCRIPTS( TITLE )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX SCRIPTS_IDX4 ON SCRIPTS( TAGS )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE GLOBAL TEMPORARY TABLE TRANSACTION_SCRIPTS_SLUGS (
    SLUG VARCHAR2(64 BYTE)
) ON COMMIT DELETE ROWS;
CREATE OR REPLACE TRIGGER SCRIPTS_BIU BEFORE INSERT OR UPDATE ON SCRIPTS FOR EACH ROW
BEGIN
    IF INSERTING THEN
        :NEW.SLUG := UTILITIES.STRING_TO_TABLE_SLUG( P_STRING => :NEW.TITLE, P_SLUG_TABLE_NAME => 'SCRIPTS' );
    END IF;
    IF UPDATING THEN
        :NEW.SLUG := :OLD.SLUG;
    END IF;
END;
/
@@../../utilities/create_before_update_trigger.sql SCRIPTS
CREATE TABLE SCRIPTS_STATEMENTS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCRIPTS_STATEMENTS_PK PRIMARY KEY ( ID ),
    SCRIPT_ID NUMBER,
    CONSTRAINT SCRIPTS_STATEMENTS_SCRIPTS_FK FOREIGN KEY ( SCRIPT_ID ) REFERENCES SCRIPTS( ID ) ON DELETE CASCADE,
    SEQUENCE NUMBER,
    CONSTRAINT SCRIPTS_STATEMENTS_UQ1 UNIQUE ( SCRIPT_ID, SEQUENCE ) DEFERRABLE INITIALLY DEFERRED USING INDEX ( CREATE INDEX SCRIPTS_STATEMENTS_IDX1 ON SCRIPTS_STATEMENTS( SCRIPT_ID, SEQUENCE ) ),
    TITLE VARCHAR2(255 BYTE),
    CONTENT CLOB NOT NULL,
    EXPECTED_RESULT CLOB,
    CONSTRAINT SCRIPTS_STATEMENTS_CHK1 CHECK ( EXPECTED_RESULT IS JSON ),
    LEGACY_ID NUMBER,
    CREATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT SCRIPTS_STATEMENTS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT SCRIPTS_STATEMENTS_USERS_FK2 FOREIGN KEY ( UPDATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX SCRIPTS_STATEMENTS_IDX2 ON SCRIPTS_STATEMENTS( CONTENT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX SCRIPTS_STATEMENTS_IDX3 ON SCRIPTS_STATEMENTS( EXPECTED_RESULT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX SCRIPTS_STATEMENTS_IDX4 ON SCRIPTS_STATEMENTS( TITLE )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
@@../../utilities/create_before_update_trigger.sql SCRIPTS_STATEMENTS
-- TODO: Decide what to do with metrics when users are deleted
CREATE TABLE SCRIPTS_METRICS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT SCRIPTS_METRICS_PK PRIMARY KEY ( ID ),
    SCRIPT_ID NUMBER NOT NULL,
    CONSTRAINT SCRIPTS_METRICS_SCRIPTS_FK FOREIGN KEY ( SCRIPT_ID ) REFERENCES SCRIPTS( ID ) ON DELETE CASCADE,
    ACTION VARCHAR2(255) NOT NULL,
    -- NOTE: There could be multiple EXECUTE rows per user
    CONSTRAINT SCRIPTS_METRICS_CHK1 CHECK ( ACTION IN ( 'VIEW', 'LIKE', 'EXECUTE', 'FAVORITE' ) ),
    CREATED_BY VARCHAR2(320 BYTE),
    -- NOTE: Remove metrics when users are deleted
    CONSTRAINT SCRIPTS_METRICS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE CASCADE,
    CONSTRAINT SCRIPTS_METRICS_CHK2 CHECK ( ACTION IN ( 'EXECUTE', 'VIEW' ) OR CREATED_BY IS NOT NULL ),
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL
)
ENABLE PRIMARY KEY USING INDEX;
-- NOTE: Allow Execute records to be duplicate for a single script but not other actions
CREATE UNIQUE INDEX SCRIPTS_METRICS_IDX1 ON SCRIPTS_METRICS(
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        ACTION
    END,
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        SCRIPT_ID
    END,
    CASE WHEN ACTION NOT IN ( 'EXECUTE', 'VIEW' ) THEN
        CREATED_BY
    END
);
CREATE INDEX SCRIPTS_METRICS_IDX2 ON SCRIPTS_METRICS( CREATED_BY, CREATED_ON );
CREATE MATERIALIZED VIEW SCRIPTS_METRICS_MV
    REFRESH FORCE ON DEMAND
    START WITH SYSDATE
    NEXT SYSDATE + 4/24
AS
    SELECT
        SCRIPT_ID AS ID,
        SUM( CASE WHEN ACTION = 'VIEW' THEN 1 ELSE 0 END) AS VIEWS,
        SUM( CASE WHEN ACTION = 'LIKE' THEN 1 ELSE 0 END) AS LIKES,
        SUM( CASE WHEN ACTION = 'FAVORITE' THEN 1 ELSE 0 END) AS FAVORITES,
        SUM( CASE WHEN ACTION = 'EXECUTION' THEN 1 ELSE 0 END) AS EXECUTIONS
    FROM
        SCRIPTS_METRICS
    GROUP BY
        SCRIPT_ID;
ALTER MATERIALIZED VIEW SCRIPTS_METRICS_MV ADD CONSTRAINT SCRIPTS_METRICS_MV_PK PRIMARY KEY ( ID );
CREATE OR REPLACE VIEW SCRIPTS_USER_METRICS (
    ID,
    VIEWS,
    EXECUTIONS,
    LAST_VIEWED_ON,
    LAST_EXECUTED_ON,
    LIKED_ON,
    FAVORITED_ON,
    CREATED_BY,
    CONSTRAINT SCRIPTS_USER_METRICS_PK PRIMARY KEY ( CREATED_BY, ID ) RELY DISABLE NOVALIDATE
) AS
SELECT
    SCRIPT_ID AS ID,
    VIEWS_COUNT AS VIEWS,
    EXECUTIONS_COUNT AS EXECUTIONS,
    VIEWS_LAST_TIMESTAMP AS LAST_VIEWED_ON,
    EXECUTIONS_LAST_TIMESTAMP AS LAST_EXECUTED_ON,
    LIKE_LAST_TIMESTAMP AS LIKED_ON,
    FAVORITE_LAST_TIMESTAMP AS FAVORITED_ON,
    CREATED_BY
FROM
    (
        -- NOTE: If we don't do this as a subquery without the ID column, the
        --       pivot takes that column into account, and if it is unique, then
        --       you will get a lot of unwanted rows
        SELECT
            SCRIPT_ID,
            ACTION,
            CREATED_BY,
            CREATED_ON
        FROM
            SCRIPTS_METRICS
        WHERE
            CREATED_BY IS NOT NULL
    )
PIVOT (
    MAX( CREATED_ON ) AS "LAST_TIMESTAMP",
    COUNT( 1 ) AS "COUNT"
    FOR ACTION IN (
        'VIEW' AS VIEWS,
        'LIKE' AS "LIKE",
        'FAVORITE' AS FAVORITE,
        'EXECUTE' AS EXECUTIONS
    )
);
-- SELECT * FROM SCRIPTS_USER_METRICS
-- NOTE: Only use common fields between the content
CREATE OR REPLACE FUNCTION CONTENT_NORMALIZED_TABLE(
    P_CONTENT_LIKE_TABLE DBMS_TF.TABLE_T,
    P_CONTENT_METRICS_MV DBMS_TF.TABLE_T,
    P_CONTENT_USER_METRICS_TABLE DBMS_TF.TABLE_T,
    P_CONTENT_TYPE VARCHAR2,
    P_SELF_URI_PREFIX VARCHAR2,
    P_CURRENT_USER VARCHAR2 DEFAULT NULL,
    P_INCLUDE_USER_METRICS_1_0 NUMBER DEFAULT 1,
    P_INCLUDE_SELF_COLUMN_1_0 NUMBER DEFAULT 1,
    P_SHORTEN_DESCRIPTION_1_0 NUMBER DEFAULT 1,
    P_INCLUDE_CONTENT_COLUMNS_1_0 NUMBER DEFAULT 1,
    P_INCLUDE_SHARE_KEY_COL_1_0 NUMBER DEFAULT 0,
    P_INCLUDE_UPDATED_BY_COL_1_0 NUMBER DEFAULT 0,
    P_INCLUDE_CONT_CAT_ID_COL_1_0 NUMBER DEFAULT 0,
    P_INCLUDE_LEGACY_COLUMNS_1_0 NUMBER DEFAULT 0,
    P_ADDITIONAL_COLUMNS DBMS_TF.COLUMNS_T DEFAULT NULL
) RETURN VARCHAR2 SQL_MACRO IS
    -- SEE: https://connor-mcdonald.com/2020/11/13/sql-macros-sql-injection/
    L_HAS_CREATED_BY_DISPLAY_NAME BOOLEAN := FALSE;
    L_HAS_UPDATED_BY_DISPLAY_NAME BOOLEAN := FALSE;
    L_HAS_SEARCH_SCORE BOOLEAN := FALSE;
    L_ADDITIONAL_COLUMNS VARCHAR2( 32767 );

    L_RESULT CLOB;
BEGIN
    FOR I IN 1 .. P_CONTENT_LIKE_TABLE.COLUMN.COUNT LOOP
        -- NOTE: Column names are quoted
        IF P_CONTENT_LIKE_TABLE.COLUMN( I ).DESCRIPTION.NAME = '"CREATED_BY_DISPLAY_NAME"' THEN
            L_HAS_CREATED_BY_DISPLAY_NAME := TRUE;
            CONTINUE;
        END IF;
        IF P_CONTENT_LIKE_TABLE.COLUMN( I ).DESCRIPTION.NAME = '"UPDATED_BY_DISPLAY_NAME"' THEN
            L_HAS_UPDATED_BY_DISPLAY_NAME := TRUE;
            CONTINUE;
        END IF;
        IF P_CONTENT_LIKE_TABLE.COLUMN( I ).DESCRIPTION.NAME = '"SEARCH_SCORE"' THEN
            L_HAS_SEARCH_SCORE := TRUE;
            CONTINUE;
        END IF;
    END LOOP;

    IF P_ADDITIONAL_COLUMNS IS NOT NULL THEN
        FOR I IN 1 .. P_ADDITIONAL_COLUMNS.COUNT LOOP
            L_ADDITIONAL_COLUMNS := L_ADDITIONAL_COLUMNS || CASE WHEN I > 1 THEN q'[,
        ]' END || 'CONTENT_LIKE_TABLE.' || P_ADDITIONAL_COLUMNS( I );
        END LOOP;
    END IF;

    DBMS_TF.TRACE( MSG => P_CONTENT_TYPE );

    DBMS_LOB.CREATETEMPORARY( LOB_LOC => L_RESULT, CACHE => FALSE, DUR => SYS.DBMS_LOB.SESSION );
    DBMS_LOB.APPEND(
        DEST_LOB => L_RESULT,
        SRC_LOB => 
q'[SELECT]' || CASE WHEN P_INCLUDE_CONTENT_COLUMNS_1_0 = 1 THEN q'[
    CONTENT_NORMALIZED_TABLE.P_CONTENT_TYPE AS CONTENT_TYPE,
    CONTENT_LIKE_TABLE.ID AS CONTENT_ID,]' ELSE q'[
    CONTENT_LIKE_TABLE.ID,]' END || CASE WHEN P_INCLUDE_SELF_COLUMN_1_0 = 1 THEN q'[
    CONTENT_NORMALIZED_TABLE.P_SELF_URI_PREFIX || CONTENT_LIKE_TABLE.SLUG || '/' AS "$self",]' END || q'[
    CONTENT_LIKE_TABLE.TITLE,]' || CASE WHEN P_SHORTEN_DESCRIPTION_1_0 = 1 THEN q'[
    -- NOTE: Limit to 280 characters
    UTILITIES.GET_CLOB_SUBSTRING_SQL( P_CLOB => CONTENT_LIKE_TABLE.DESCRIPTION, P_LENGTH => 280 ) AS DESCRIPTION,]' ELSE q'[
    CONTENT_LIKE_TABLE.DESCRIPTION,]' END || q'[
    CONTENT_LIKE_TABLE.TAGS,
    CONTENT_LIKE_TABLE.MINIMUM_DATABASE_VERSION,]' || CASE WHEN P_INCLUDE_SHARE_KEY_COL_1_0 = 1 THEN q'[
    CONTENT_LIKE_TABLE.SHARE_KEY,]' END || CASE WHEN P_INCLUDE_CONT_CAT_ID_COL_1_0 = 1 THEN q'[
    CONTENT_LIKE_TABLE.CONTENT_CATEGORY_ID,]' END || q'[
    CONTENT_LIKE_TABLE.SLUG,
    CONTENT_LIKE_TABLE.IS_PUBLISHED,
    CONTENT_LIKE_TABLE.IS_FEATURED,
    NVL2( CONTENT_LIKE_TABLE.SHARE_KEY, 'Y', 'N' ) AS IS_SHARED,]' || CASE WHEN P_INCLUDE_USER_METRICS_1_0 = 1 THEN q'[
    NVL2( CONTENT_USER_METRICS.LAST_VIEWED_ON, 'Y', 'N' ) AS IS_MY_VIEWED,
    NVL2( CONTENT_USER_METRICS.LIKED_ON, 'Y', 'N' ) AS IS_MY_LIKED,
    NVL2( CONTENT_USER_METRICS.FAVORITED_ON, 'Y', 'N' ) AS IS_MY_FAVORITE,
    NVL2( CONTENT_USER_METRICS.LAST_EXECUTED_ON, 'Y', 'N' ) AS IS_MY_EXECUTED,
    CASE WHEN CONTENT_LIKE_TABLE.CREATED_BY = CONTENT_NORMALIZED_TABLE.P_CURRENT_USER THEN 'Y' ELSE 'N' END AS IS_MY_CREATED,
    CONTENT_USER_METRICS.LAST_VIEWED_ON,
    CONTENT_USER_METRICS.LAST_EXECUTED_ON,
    -- NOTE: Account for materialized view delays. If the current user acted on
    --       content at least output the actions of the user
    GREATEST( NVL( CONTENT_METRICS.VIEWS, 0 ), NVL( CONTENT_USER_METRICS.VIEWS, 0 ) ) AS VIEWS,
    NVL( CONTENT_METRICS.LIKES, NVL2( CONTENT_USER_METRICS.LIKED_ON, 1, 0 ) ) AS LIKES,
    NVL( CONTENT_METRICS.FAVORITES, NVL2( CONTENT_USER_METRICS.FAVORITED_ON, 1, 0 ) ) AS FAVORITES,
    GREATEST( NVL( CONTENT_METRICS.EXECUTIONS, 0 ), NVL( CONTENT_USER_METRICS.EXECUTIONS, 0 ) ) AS EXECUTIONS,]' ELSE q'[
    NVL( CONTENT_METRICS.VIEWS, 0 ) AS VIEWS,
    NVL( CONTENT_METRICS.LIKES, 0 ) AS LIKES,
    NVL( CONTENT_METRICS.FAVORITES, 0 ) AS FAVORITES,
    NVL( CONTENT_METRICS.EXECUTIONS, 0 ) AS EXECUTIONS,]' END || CASE WHEN P_INCLUDE_LEGACY_COLUMNS_1_0 = 1 THEN q'[
    CONTENT_LIKE_TABLE.LEGACY_ID,
    CONTENT_LIKE_TABLE.LEGACY_FILE_NAME,]' END || q'[
    CONTENT_LIKE_TABLE.]' || CASE WHEN L_HAS_CREATED_BY_DISPLAY_NAME THEN '"CREATED_BY_DISPLAY_NAME"' ELSE '"CREATED_BY"' END || q'[,
    CONTENT_LIKE_TABLE.CREATED_ON,]' || CASE WHEN P_INCLUDE_UPDATED_BY_COL_1_0 = 1 THEN q'[
    CONTENT_LIKE_TABLE.]' || CASE WHEN L_HAS_UPDATED_BY_DISPLAY_NAME THEN '"UPDATED_BY_DISPLAY_NAME"' ELSE '"UPDATED_BY"' END || q'[,]' END || q'[
    CONTENT_LIKE_TABLE.UPDATED_ON]' || CASE WHEN L_HAS_SEARCH_SCORE THEN q'[,
    CONTENT_LIKE_TABLE.SEARCH_SCORE]' END || CASE WHEN L_ADDITIONAL_COLUMNS IS NOT NULL THEN q'[,
    ]' END
    );
    IF L_ADDITIONAL_COLUMNS IS NOT NULL THEN
        DBMS_LOB.APPEND(
            DEST_LOB => L_RESULT,
            SRC_LOB => L_ADDITIONAL_COLUMNS
        );
    END IF;
    DBMS_LOB.APPEND(
        DEST_LOB => L_RESULT,
        SRC_LOB => q'[
FROM
    P_CONTENT_LIKE_TABLE CONTENT_LIKE_TABLE LEFT JOIN P_CONTENT_METRICS_MV CONTENT_METRICS ON
        CONTENT_LIKE_TABLE.ID = CONTENT_METRICS.ID]' || CASE WHEN P_INCLUDE_USER_METRICS_1_0 = 1 THEN q'[
    LEFT JOIN P_CONTENT_USER_METRICS_TABLE CONTENT_USER_METRICS ON
        CONTENT_USER_METRICS.CREATED_BY = CONTENT_NORMALIZED_TABLE.P_CURRENT_USER
        AND CONTENT_LIKE_TABLE.ID = CONTENT_USER_METRICS.ID]' END
    );

    DBMS_OUTPUT.PUT_LINE( L_RESULT );
    RETURN L_RESULT;
END;
/
CREATE OR REPLACE VIEW CONTENT_ITEMS (
    CONTENT_TYPE,
    CONTENT_ID,
    TITLE,
    DESCRIPTION,
    TAGS,
    MINIMUM_DATABASE_VERSION,
    SHARE_KEY,
    CONTENT_CATEGORY_ID,
    SLUG,
    IS_PUBLISHED,
    IS_FEATURED,
    IS_SHARED,
    VIEWS,
    LIKES,
    FAVORITES,
    EXECUTIONS,
    LEGACY_ID,
    LEGACY_FILE_NAME,
    CREATED_BY,
    CREATED_ON,
    UPDATED_BY,
    UPDATED_ON,
    CONSTRAINT CONTENT_ITEMS_PK PRIMARY KEY ( CONTENT_TYPE, CONTENT_ID ) RELY DISABLE NOVALIDATE
) AS
SELECT
    *
FROM
    CONTENT_NORMALIZED_TABLE(
        P_CONTENT_LIKE_TABLE => TUTORIALS,
        P_CONTENT_METRICS_MV => TUTORIALS_METRICS_MV,
        P_CONTENT_USER_METRICS_TABLE => TUTORIALS_USER_METRICS,
        P_CONTENT_TYPE => 'TUTORIAL',
        P_SELF_URI_PREFIX => 'tutorial/',
        P_CURRENT_USER => NULL,
        P_INCLUDE_USER_METRICS_1_0 => 0,
        P_INCLUDE_SELF_COLUMN_1_0 => 0,
        P_SHORTEN_DESCRIPTION_1_0 => 0,
        P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
        P_INCLUDE_UPDATED_BY_COL_1_0 => 1,
        P_INCLUDE_CONT_CAT_ID_COL_1_0 => 1,
        P_INCLUDE_LEGACY_COLUMNS_1_0 => 1
    )
UNION ALL
SELECT
    *
FROM
    CONTENT_NORMALIZED_TABLE(
        P_CONTENT_LIKE_TABLE => SCRIPTS,
        P_CONTENT_METRICS_MV => SCRIPTS_METRICS_MV,
        P_CONTENT_USER_METRICS_TABLE => SCRIPTS_USER_METRICS,
        P_CONTENT_TYPE => 'SCRIPT',
        P_SELF_URI_PREFIX => 'script/',
        P_CURRENT_USER => NULL,
        P_INCLUDE_USER_METRICS_1_0 => 0,
        P_INCLUDE_SELF_COLUMN_1_0 => 0,
        P_SHORTEN_DESCRIPTION_1_0 => 0,
        P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
        P_INCLUDE_UPDATED_BY_COL_1_0 => 1,
        P_INCLUDE_CONT_CAT_ID_COL_1_0 => 1,
        P_INCLUDE_LEGACY_COLUMNS_1_0 => 1
    );
-- SELECT * FROM CONTENT_ITEMS
CREATE OR REPLACE VIEW CONTENT_ITEMS_USER_METRICS (
    CONTENT_TYPE,
    CONTENT_ID,
    VIEWS,
    EXECUTIONS,
    LAST_VIEWED_ON,
    LAST_EXECUTED_ON,
    LIKED_ON,
    FAVORITED_ON,
    CREATED_BY,
    CONSTRAINT CONTENT_ITEMS_USER_METRICS_PK PRIMARY KEY ( CONTENT_TYPE, CREATED_BY, CONTENT_ID ) RELY DISABLE NOVALIDATE
) AS
SELECT
    *
FROM (
    SELECT
        'TUTORIALS' AS CONTENT_TYPE,
        ID AS CONTENT_ID,
        VIEWS,
        EXECUTIONS,
        LAST_VIEWED_ON,
        LAST_EXECUTED_ON,
        LIKED_ON,
        FAVORITED_ON,
        CREATED_BY
    FROM
        TUTORIALS_USER_METRICS
    UNION ALL
    SELECT
        'SCRIPTS' AS CONTENT_TYPE,
        ID AS CONTENT_ID,
        VIEWS,
        EXECUTIONS,
        LAST_VIEWED_ON,
        LAST_EXECUTED_ON,
        LIKED_ON,
        FAVORITED_ON,
        CREATED_BY
    FROM
        SCRIPTS_USER_METRICS
);
-- SELECT * FROM CONTENT_ITEMS_USER_METRICS
CREATE TABLE WORKSHEETS (
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    CONSTRAINT WORKSHEETS_PK PRIMARY KEY ( ID ),
    NAME VARCHAR2(128 BYTE) NOT NULL,
    CODE_LANGUAGE VARCHAR2(32 BYTE) DEFAULT ON NULL 'PL_SQL' NOT NULL,
    CONSTRAINT WORKSHEETS_CHK1 CHECK ( CODE_LANGUAGE IN ( 'PL_SQL', 'QUICK_SQL', 'JAVASCRIPT' ) ),
    CONTENT CLOB NOT NULL,
    LAST_OPENED_ON TIMESTAMP (6) WITH TIME ZONE,
    CREATED_BY VARCHAR2(320 BYTE),
    -- NOTE: Remove the worksheet when the creator is deleted
    CONSTRAINT WORKSHEETS_USERS_FK1 FOREIGN KEY ( CREATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE CASCADE,
    CREATED_ON TIMESTAMP (6) WITH TIME ZONE DEFAULT ON NULL CURRENT_TIMESTAMP NOT NULL,
    UPDATED_BY VARCHAR2(320 BYTE),
    CONSTRAINT WORKSHEETS_USERS_FK2 FOREIGN KEY ( UPDATED_BY ) REFERENCES USERS( EMAIL ) ON DELETE SET NULL,
    UPDATED_ON TIMESTAMP (6) WITH TIME ZONE
)
ENABLE PRIMARY KEY USING INDEX;
CREATE INDEX WORKSHEETS_IDX1 ON WORKSHEETS( CONTENT )
    INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ( 'ASYNCHRONOUS_UPDATE SYNC ( ON COMMIT )' );
CREATE INDEX LIVE_SQL.WORKSHEETS_IDX2 ON LIVE_SQL.WORKSHEETS ( NAME, CREATED_BY );
@@../../utilities/create_before_update_trigger.sql WORKSHEETS
CREATE MATERIALIZED VIEW CONTENT_DATABASE_VERSIONS_MV
    REFRESH FORCE ON DEMAND
    START WITH SYSDATE
    NEXT (SYSDATE + 4/24 )
AS
    SELECT
        MINIMUM_DATABASE_VERSION,
        SUM(CONTENT_ITEMS) AS TOTAL_ITEMS
    FROM
        (
            SELECT
                MINIMUM_DATABASE_VERSION,
                COUNT( 1 ) AS CONTENT_ITEMS
            FROM
                TUTORIALS
            GROUP BY
                MINIMUM_DATABASE_VERSION
            UNION ALL
            SELECT
                MINIMUM_DATABASE_VERSION,
                COUNT( 1 ) AS CONTENT_ITEMS
            FROM
                SCRIPTS
            GROUP BY
                MINIMUM_DATABASE_VERSION
        ) COMBINED_VERSIONS
    GROUP BY
        MINIMUM_DATABASE_VERSION;

BEGIN
    -- NOTE: Using AES256 algorithm which requires a 256 bit (32 Byte)
    --       encryption key. Genrated with RAWTOHEX( DBMS_CRYPTO.RANDOMBYTES( 32 ) )
    SET_PARAMETER( 'ENCRYPTION_KEY', 'A3272D87714DAF7784D313006CEE70ED736102E401B6EE24FC484A857BD9B48B' );
    -- Note: generated with DBMS_CRYPTO.RANDOMBYTES( 16 )
    SET_PARAMETER( 'ENCRYPTION_IV', '6B6592C26314C9CB173A19611304962A' );
END;
/

CREATE OR REPLACE PACKAGE AUTHORIZATION AS
    FUNCTION GET_ASSIGNED_ROLE( P_EMAIL VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION GET_ROLES( P_EMAIL VARCHAR2 ) RETURN VC2_TABLE_T;
    FUNCTION HAS_ALL_ROLES( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN BOOLEAN;
    FUNCTION HAS_ALL_ROLES_YN( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN VARCHAR2;
    FUNCTION HAS_ANY_ROLES( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN BOOLEAN;
    FUNCTION HAS_ANY_ROLES_YN( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN VARCHAR2;
    FUNCTION HAS_ROLE( P_EMAIL VARCHAR2, P_ROLE VARCHAR2 ) RETURN BOOLEAN;
    FUNCTION HAS_ROLE_YN( P_EMAIL VARCHAR2, P_ROLE VARCHAR2 ) RETURN VARCHAR;
END AUTHORIZATION;
/
CREATE OR REPLACE PACKAGE BODY AUTHORIZATION AS
    FUNCTION GET_ASSIGNED_ROLE( P_EMAIL VARCHAR2 ) RETURN VARCHAR2 IS
        L_ROLE USERS.EMAIL%TYPE;
    BEGIN
        IF P_EMAIL IS NULL THEN
            RETURN NULL;
        END IF;

        SELECT
            ROLES.NAME
        INTO
            L_ROLE
        FROM
            USERS JOIN ROLES ON
                USERS.EMAIL = P_EMAIL
                AND ROLES.ID = USERS.ROLE_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_ASSIGNED_ROLE;

    FUNCTION GET_ROLES( P_EMAIL VARCHAR2 ) RETURN VC2_TABLE_T IS
        L_ROLES VC2_TABLE_T := VC2_TABLE_T();
    BEGIN
        IF P_EMAIL IS NULL THEN
            RETURN L_ROLES;
        END IF;

        SELECT
            ROLES.NAME
        BULK COLLECT INTO
            L_ROLES
        FROM
            ROLES
        JOIN (
            SELECT
                SEQUENCE
            FROM
                ROLES
            WHERE
                ID = (
                    SELECT
                        ROLE_ID
                    FROM
                        USERS
                    WHERE
                        EMAIL = P_EMAIL
                        AND DISCLAIMER_ACCEPTED_ON IS NOT NULL
                )
        ) USER_ROLE_SEQUENCE ON
            ROLES.SEQUENCE <= USER_ROLE_SEQUENCE.SEQUENCE
        ORDER BY
            ROLES.SEQUENCE DESC;

        RETURN L_ROLES;
    END GET_ROLES;

    FUNCTION HAS_ALL_ROLES( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN BOOLEAN IS
        L_ROLES VC2_TABLE_T := GET_ROLES( P_EMAIL );
        L_MINUS VC2_TABLE_T;
    BEGIN
        IF P_EMAIL IS NULL OR P_ROLES IS EMPTY OR L_ROLES IS EMPTY THEN
            RETURN FALSE;
        END IF;

        L_MINUS := P_ROLES MULTISET EXCEPT L_ROLES;

        RETURN L_MINUS.COUNT = 0;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END HAS_ALL_ROLES;

    FUNCTION HAS_ALL_ROLES_YN( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN VARCHAR2 IS
    BEGIN
        RETURN UTILITIES.BOOLEAN_TO_YN( HAS_ALL_ROLES( P_EMAIL, P_ROLES ) );
    END HAS_ALL_ROLES_YN;

    FUNCTION HAS_ANY_ROLES( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN BOOLEAN IS
        L_ROLES VC2_TABLE_T := GET_ROLES( P_EMAIL );
        L_INTERSECT VC2_TABLE_T;
    BEGIN
        IF P_EMAIL IS NULL OR P_ROLES IS EMPTY OR L_ROLES IS EMPTY THEN
            RETURN FALSE;
        END IF;

        L_INTERSECT := P_ROLES MULTISET INTERSECT L_ROLES;

        RETURN L_INTERSECT.COUNT > 0;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END HAS_ANY_ROLES;

    FUNCTION HAS_ANY_ROLES_YN( P_EMAIL VARCHAR2, P_ROLES VC2_TABLE_T ) RETURN VARCHAR2 IS
    BEGIN
        RETURN UTILITIES.BOOLEAN_TO_YN( HAS_ANY_ROLES( P_EMAIL, P_ROLES ) );
    END HAS_ANY_ROLES_YN;

    FUNCTION HAS_ROLE( P_EMAIL VARCHAR2, P_ROLE VARCHAR2 ) RETURN BOOLEAN IS
        L_ROLES VC2_TABLE_T := GET_ROLES( P_EMAIL );
    BEGIN
        RETURN P_EMAIL IS NOT NULL AND L_ROLES IS NOT EMPTY AND P_ROLE MEMBER OF L_ROLES;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END HAS_ROLE;

    FUNCTION HAS_ROLE_YN( P_EMAIL VARCHAR2, P_ROLE VARCHAR2 ) RETURN VARCHAR IS
    BEGIN
        RETURN UTILITIES.BOOLEAN_TO_YN( HAS_ROLE( P_EMAIL, P_ROLE ) );
    END HAS_ROLE_YN;
END AUTHORIZATION;
/
CREATE OR REPLACE PACKAGE SCHEMA_MANAGEMENT AS
    FUNCTION DOES_SCHEMA_EXISTS( P_DATABASE_ID NUMBER, P_SCHEMA_NAME VARCHAR2 ) RETURN BOOLEAN;
    PROCEDURE REQUEST_SCHEMAS_CREATION( P_DATABASE_ID NUMBER, P_NUMBER_OF_SCHEMAS NUMBER DEFAULT 1, P_ARE_SCHEMAS_READ_ONLY_YN VARCHAR2 DEFAULT 'N' );
    FUNCTION GET_ASSIGNED_SCHEMA_ID( P_DATABASE_ID NUMBER, P_EMAIL VARCHAR2 ) RETURN NUMBER;
    FUNCTION ASSIGN_SCHEMA( P_DATABASE_ID NUMBER, P_EMAIL VARCHAR2 ) RETURN NUMBER;
END SCHEMA_MANAGEMENT;
/
CREATE OR REPLACE PACKAGE BODY SCHEMA_MANAGEMENT AS
    FUNCTION DOES_SCHEMA_EXISTS( P_DATABASE_ID NUMBER, P_SCHEMA_NAME VARCHAR2 ) RETURN BOOLEAN IS
        L_COUNT NUMBER;
    BEGIN
        SELECT
            COUNT(1)
        INTO
            L_COUNT
        FROM
            SCHEMAS
        WHERE
            DATABASE_ID = P_DATABASE_ID
            AND NAME = P_SCHEMA_NAME;

        RETURN L_COUNT > 0;
    END DOES_SCHEMA_EXISTS;

    PROCEDURE REQUEST_SCHEMAS_CREATION( P_DATABASE_ID NUMBER, P_NUMBER_OF_SCHEMAS NUMBER DEFAULT 1, P_ARE_SCHEMAS_READ_ONLY_YN VARCHAR2 DEFAULT 'N' ) IS
        L_BASE_URL DATABASES.BASE_URL%TYPE;
        L_ADMIN_SCHEMA_ALIAS DATABASES.ADMIN_SCHEMA_ALIAS%TYPE;
        L_ADMIN_CLIENT_ID DATABASES.ADMIN_CLIENT_ID%TYPE;
        L_ADMIN_CLIENT_SECRET DATABASES.ADMIN_CLIENT_SECRET%TYPE;

        L_BODY CLOB;
        L_RESPONSE CLOB;
    BEGIN
        BEGIN
            SELECT
                JSON_OBJECT(
                    KEY 'number_of_schemas' VALUE P_NUMBER_OF_SCHEMAS,
                    KEY 'are_schemas_read_only' VALUE P_ARE_SCHEMAS_READ_ONLY_YN
                    RETURNING CLOB
                ),
                BASE_URL,
                ADMIN_SCHEMA_ALIAS,
                UTILITIES.HEX_DECRYPT( ADMIN_CLIENT_ID ),
                UTILITIES.HEX_DECRYPT( ADMIN_CLIENT_SECRET )
            INTO
                L_BODY,
                L_BASE_URL,
                L_ADMIN_SCHEMA_ALIAS,
                L_ADMIN_CLIENT_ID,
                L_ADMIN_CLIENT_SECRET
            FROM
                DATABASES
            WHERE
                ID = P_DATABASE_ID;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR( -20000, 'Database does not exist' );
        END;

        APEX_WEB_SERVICE.OAUTH_AUTHENTICATE(
            P_TOKEN_URL => L_BASE_URL || L_ADMIN_SCHEMA_ALIAS || '/oauth/token',
            P_CLIENT_ID => L_ADMIN_CLIENT_ID,
            P_CLIENT_SECRET => L_ADMIN_CLIENT_SECRET,
            P_FLOW_TYPE => APEX_WEB_SERVICE.OAUTH_CLIENT_CRED
        );
        IF APEX_WEB_SERVICE.G_STATUS_CODE != 200 THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while requesting schemas'' creation. OAuth authentication request to the database returned with status ' || APEX_WEB_SERVICE.G_STATUS_CODE );
        END IF;

        APEX_WEB_SERVICE.G_REQUEST_HEADERS(1).NAME := 'Authorization';
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(1).VALUE := 'Bearer ' || APEX_WEB_SERVICE.OAUTH_GET_LAST_TOKEN();
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(2).NAME := 'Content-Type';
        APEX_WEB_SERVICE.G_REQUEST_HEADERS(2).VALUE := 'application/json';

        L_RESPONSE := APEX_WEB_SERVICE.MAKE_REST_REQUEST(
            P_URL => L_BASE_URL || L_ADMIN_SCHEMA_ALIAS || '/api/jobs/schema_creation/',
            P_HTTP_METHOD => 'POST',
            P_BODY => L_BODY
        );
        IF APEX_WEB_SERVICE.G_STATUS_CODE != 200 AND APEX_WEB_SERVICE.G_STATUS_CODE != 201 THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while requesting schemas'' creation. Request returned with HTTP status code ' || APEX_WEB_SERVICE.G_STATUS_CODE );
        END IF;
    END REQUEST_SCHEMAS_CREATION;

    FUNCTION GET_ASSIGNED_SCHEMA_ID( P_DATABASE_ID NUMBER, P_EMAIL VARCHAR2 ) RETURN NUMBER IS
        L_SCHEMA_ID NUMBER;
    BEGIN
        SELECT
            ID
        INTO
            L_SCHEMA_ID
        FROM
            SCHEMAS
        WHERE
            DATABASE_ID = P_DATABASE_ID
            AND ASSIGNED_TO = P_EMAIL;

        RETURN L_SCHEMA_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_ASSIGNED_SCHEMA_ID;

    FUNCTION ASSIGN_SCHEMA( P_DATABASE_ID NUMBER, P_EMAIL VARCHAR2 ) RETURN NUMBER IS
        L_SCHEMA_ID NUMBER := GET_ASSIGNED_SCHEMA_ID( P_DATABASE_ID, P_EMAIL );
    BEGIN
        IF L_SCHEMA_ID IS NOT NULL THEN
            RETURN L_SCHEMA_ID;
        END IF;

        BEGIN
            SELECT
                ID
            INTO
                L_SCHEMA_ID
            FROM
                SCHEMAS
            WHERE
                STATUS = 'AVAILABLE'
                AND ASSIGNED_TO IS NULL
                AND DATABASE_ID = P_DATABASE_ID
            ORDER BY
                DBMS_RANDOM.RANDOM
            FETCH
                FIRST ROW ONLY;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR( -20000, 'An error occurred while assigning a schema. No schemas available' );
        END;

        UPDATE
            SCHEMAS
        SET
            ASSIGNED_TO = P_EMAIL,
            STATUS = 'ASSIGNED'
        WHERE
            ID = L_SCHEMA_ID;
        COMMIT;

        RETURN L_SCHEMA_ID;
    END ASSIGN_SCHEMA;
END SCHEMA_MANAGEMENT;
/
CREATE OR REPLACE PACKAGE USER_SCHEMAS AS
    -- FUNCTIONS
    FUNCTION GET_DATABASE_VERSION RETURN DATABASES.VERSION%TYPE;
    FUNCTION GET_READ_ONLY_SCHEMA (
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T;
    FUNCTION GET_USER_SCHEMA (
        P_USER    VARCHAR2,
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T;
    FUNCTION ASSIGN_SCHEMA_TO_USER (
        P_USER    VARCHAR2,
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T;
END;
/
CREATE OR REPLACE PACKAGE BODY USER_SCHEMAS AS
    FUNCTION GET_DATABASE_VERSION RETURN DATABASES.VERSION%TYPE IS
        L_VERSION DATABASES.VERSION%TYPE;
    BEGIN
        SELECT
            VERSION
        INTO
            L_VERSION
        FROM
            DATABASES
        ORDER BY
            -- NOTE: Pick the newest one by default because is the less likely to
            --       have a lot of schemas created
            -- NOTE: This sorts the schema by version number considering the
            --       version is in one of the following formats: 0 | 0.0 | 0.0.0
            TO_NUMBER(REGEXP_SUBSTR( VERSION, '\\d+', 1, 1)) DESC NULLS LAST,
            TO_NUMBER(REGEXP_SUBSTR( VERSION, '\\d+', 1, 2)) DESC NULLS LAST,
            TO_NUMBER(REGEXP_SUBSTR( VERSION, '\\d+', 1, 3)) DESC NULLS LAST
        FETCH FIRST ROW ONLY;

        RETURN L_VERSION;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while obtaining the database version. No databases available' );
    END GET_DATABASE_VERSION;

    FUNCTION GET_READ_ONLY_SCHEMA (
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T IS
        L_VERSION DATABASES.VERSION%TYPE := NVL( P_VERSION, GET_DATABASE_VERSION() );
        L_USER_SCHEMA USER_SCHEMA_T;
    BEGIN
        SELECT
            USER_SCHEMA_T(
                SCHEMAS.ID,
                SCHEMAS.NAME,
                SCHEMAS.ALIAS,
                DATABASES.VERSION,
                DATABASES.BASE_URL,
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_ID ),
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_SECRET )
            )
        INTO
            L_USER_SCHEMA
        FROM
            SCHEMAS JOIN DATABASES ON
                SCHEMAS.DATABASE_ID = DATABASES.ID
        WHERE
            DATABASES.VERSION = L_VERSION
            AND SCHEMAS.STATUS = 'AVAILABLE'
            AND SCHEMAS.IS_READ_ONLY = 'Y'
        ORDER BY
            DBMS_RANDOM.RANDOM
        FETCH FIRST ROW ONLY;

        RETURN L_USER_SCHEMA;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while obtaining a read-only schema. No schemas available' );
    END GET_READ_ONLY_SCHEMA;

    FUNCTION ASSIGN_SCHEMA_TO_USER (
        P_USER    VARCHAR2,
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T IS
        L_VERSION DATABASES.VERSION%TYPE := NVL( P_VERSION, GET_DATABASE_VERSION() );
        L_USER_SCHEMA USER_SCHEMA_T;
        L_DATABASE_ID DATABASES.ID%TYPE;
    BEGIN
        L_USER_SCHEMA := GET_USER_SCHEMA( P_USER, P_VERSION );
        IF L_USER_SCHEMA IS NOT NULL THEN
            RETURN L_USER_SCHEMA;
        END IF;

        SELECT
            USER_SCHEMA_T(
                SCHEMAS.ID,
                SCHEMAS.NAME,
                SCHEMAS.ALIAS,
                DATABASES.VERSION,
                DATABASES.BASE_URL,
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_ID ),
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_SECRET )
            ),
            DATABASES.ID
        INTO
            L_USER_SCHEMA,
            L_DATABASE_ID
        FROM
            SCHEMAS JOIN DATABASES ON
                SCHEMAS.DATABASE_ID = DATABASES.ID
        WHERE
            DATABASES.VERSION = L_VERSION
            AND SCHEMAS.STATUS = 'AVAILABLE'
            AND SCHEMAS.IS_READ_ONLY = 'N'
            AND SCHEMAS.ASSIGNED_TO IS NULL
        ORDER BY
            DBMS_RANDOM.RANDOM
        FETCH FIRST ROW ONLY;

        UPDATE
            SCHEMAS
        SET
            ASSIGNED_TO = P_USER,
            STATUS = 'ASSIGNED'
        WHERE
            ID = L_USER_SCHEMA.ID;

        BEGIN
            SCHEMA_MANAGEMENT.REQUEST_SCHEMAS_CREATION(
                P_DATABASE_ID => L_DATABASE_ID,
                P_NUMBER_OF_SCHEMAS => 1,
                P_ARE_SCHEMAS_READ_ONLY_YN => 'N'
            );
        EXCEPTION
            -- NOTE: This call shouldn't prevent the user from getting a schema
            --       assigned
            -- TODO: Improve logging and error handling
            WHEN OTHERS THEN
                NULL;
        END;

        RETURN L_USER_SCHEMA;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR( -20000, 'An error occurred while assigning a schema. No schemas available' );
    END ASSIGN_SCHEMA_TO_USER;

    FUNCTION GET_USER_SCHEMA (
        P_USER VARCHAR2,
        P_VERSION DATABASES.VERSION%TYPE DEFAULT NULL
    ) RETURN USER_SCHEMA_T IS
        L_VERSION DATABASES.VERSION%TYPE := NVL( P_VERSION, GET_DATABASE_VERSION() );
        L_USER_SCHEMA USER_SCHEMA_T;
    BEGIN
        SELECT
            USER_SCHEMA_T(
                SCHEMAS.ID,
                SCHEMAS.NAME,
                SCHEMAS.ALIAS,
                DATABASES.VERSION,
                DATABASES.BASE_URL,
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_ID ),
                UTILITIES.HEX_DECRYPT( SCHEMAS.CLIENT_SECRET )
            )
        INTO
            L_USER_SCHEMA
        FROM
            SCHEMAS JOIN DATABASES ON
                SCHEMAS.DATABASE_ID = DATABASES.ID
        WHERE
            DATABASES.VERSION = L_VERSION
            AND SCHEMAS.ASSIGNED_TO = P_USER;

        RETURN L_USER_SCHEMA;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_USER_SCHEMA;
END USER_SCHEMAS;
/

PROMPT INFO: Live SQL METADATA Objects created
