
-- Generated by ORDS REST Data Services 24.3.1.r3061450
-- Schema: LIVE_SQL  Date: Mon Jun 09 09:13:43 2025 
--
        
BEGIN
  ORDS.DEFINE_MODULE(
      p_module_name    => 'com.oracle.livesql.api',
      p_base_path      => '/api/',
      p_items_per_page => 25,
      p_status         => 'PUBLISHED',
      p_comments       => NULL);

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_SLUG TUTORIALS.SLUG%TYPE;

    UNAUTHORIZED EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        RAISE UNAUTHORIZED;
    END IF;

    INSERT INTO TUTORIALS (
        TITLE,
        DESCRIPTION,
        SETUP_CODE,
        SETUP_CODE_LANGUAGE,
        MINIMUM_DATABASE_VERSION,
        TAGS,
        SHARE_KEY,
        CONTENT_CATEGORY_ID,
        SLUG,
        IS_PUBLISHED,
        IS_FEATURED,
        LEGACY_ID,
        LEGACY_FILE_NAME,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    ) VALUES (
        :title,
        :description,
        :setup_code,
        :setup_code_language,
        :minimum_database_version,
        :tags,
        NULL,
        NULL,
        NULL,
        ''N'',
        ''N'',
        NULL,
        NULL,
        L_CURRENT_USER,
        NULL,
        L_CURRENT_USER,
        NULL
    ) RETURNING SLUG INTO L_SLUG;
   ' || ' :status_code := 201;
    :forward_location := L_SLUG  || ''/'';
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID TUTORIALS.ID%TYPE;
    L_IS_PUBLISHED_YN VARCHAR2(1);
    L_IS_SHARED_YN VARCHAR2(1);
    L_IS_MATCHING_SHARE_KEY_YN VARCHAR2(1);
    L_IS_MY_CREATED_YN VARCHAR2(1);

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF
        :action IS NULL
        OR (
            NOT UTILITIES.IS_VALID_CONENT_ACTION( :action )
            AND :action NOT IN ( ''UNLIKE'', ''UNFAVORITE'', ''SHARE'', ''UNSHARE'' )
        )
    THEN
        RAISE BAD_REQUEST;
    END IF;

    BEGIN
        SELECT
            ID,
            IS_PUBLISHED,
            CASE WHEN SHARE_KEY IS NOT NULL THEN ''Y'' ELSE ''N'' END AS IS_SHARED,
            CASE WHEN SHARE_KEY IS NOT NULL AND SHARE_KEY = :share_key THEN ''Y'' ELSE ''N'' END AS IS_MATCHING_SHARE_KEY,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            ' || 'L_IS_PUBLISHED_YN,
            L_IS_SHARED_YN,
            L_IS_MATCHING_SHARE_KEY_YN,
            L_IS_MY_CREATED_YN
        FROM
            TUTORIALS
        WHERE
            SLUG = :tutorial_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        L_CURRENT_USER IS NULL
        AND :action NOT IN ( ''VIEW'', ''EXECUTE'' )
    THEN
        RAISE UNAUTHORIZED;
    END IF;

    IF
        -- NOTE: Administrators don''t get to register an action if the
        --       tutorial isn''t public, shared or doesn''t belong to them
        (
            L_CURRENT_USER IS NOT NULL
            AND NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' )
        ) OR (
            :action IN ( ''SHARE'', ''UNSHARE'' )
            AND L_IS_MY_CREATED_YN != ''Y''
        ) OR (
            L_IS_PUBLISHED_YN != ''Y''
            AND L_IS_MY_CREATED_YN != ''Y''
            AND L_IS_MATCHING_SHARE_KEY_YN != ''Y''
        )
    THEN
        RAISE FORBIDDEN;
    END IF;

  ' || '  IF :action IN ( ''UNLIKE'', ''UNFAVORITE'' ) THEN
        -- NOTE: Doesn''t matter if it doesn''t exist
        DELETE
        FROM
            TUTORIALS_METRICS
        WHERE
            ACTION = CASE :action
                WHEN ''UNLIKE'' THEN
                    ''LIKE''
                WHEN ''UNFAVORITE'' THEN
                    ''FAVORITE''
            END
            AND TUTORIAL_ID = L_ID;

        :status_code := 204;
        RETURN;
    END IF;

    IF :action IN ( ''SHARE'', ''UNSHARE'' ) THEN
        -- NOTE: Doesn''t matter if it doesn''t exist
        UPDATE
            TUTORIALS
        SET
            SHARE_KEY = CASE :action WHEN ''SHARE'' THEN UTILITIES.GET_SHARE_KEY() END
        WHERE
            ID = L_ID;

        :status_code := 200;
        :forward_location := :tutorial_slug;
        RETURN;
    END IF;

    INSERT INTO TUTORIALS_METRICS (
        TUTORIAL_ID,
        ACTION,
        CREATED_BY
    ) VALUES (
        L_ID,
        :action,
        L_CURRENT_USER
    );
    :statu' || 's_code := 204;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    SINGLE_TUTORIAL AS (
        SELECT
            TUTORIALS.*,
            CREATED_BY_USERS.DISPLAY_NAME AS CREATED_BY_DISPLAY_NAME,
            UPDATED_BY_USERS.DISPLAY_NAME AS UPDATED_BY_DISPLAY_NAME
        FROM
            TUTORIALS LEFT JOIN USERS CREATED_BY_USERS ON
                TUTORIALS.CREATED_BY = CREATED_BY_USERS.EMAIL
            LEFT JOIN USERS UPDATED_BY_USERS ON
                TUTORIALS.UPDATED_BY = UPDATED_BY_USERS.EMAIL
        WHERE
            TUTORIALS.SLUG = :tutorial_slug
            AND (
                IS_PUBLISHED = ''Y''
                OR CREATED_BY = UPPER( :current_user )
                OR SHARE_KEY = :share_key
                OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
            )
    )
SELECT
    CONTENT_SINGLE_TUTORIAL.TITLE,
    CONTENT_SINGLE_TUTORIAL.DESCRIPTION,
    CONTENT_SINGLE_TUTORIAL.SETUP_CODE,
    CONTENT_SINGLE_TUTORIAL.SETUP_CODE_LANGUAGE,
    CONTENT_SINGLE_TUTORIAL.MINIM' || 'UM_DATABASE_VERSION,
    CONTENT_SINGLE_TUTORIAL.TAGS,
    CASE
        WHEN
            CONTENT_SINGLE_TUTORIAL.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_TUTORIAL.SHARE_KEY
    END AS SHARE_KEY,
    -- CONTENT_SINGLE_TUTORIAL.CONTENT_CATEGORY_ID,
    CONTENT_SINGLE_TUTORIAL.SLUG,
    CONTENT_SINGLE_TUTORIAL.IS_PUBLISHED,
    CONTENT_SINGLE_TUTORIAL.IS_FEATURED,
    CONTENT_SINGLE_TUTORIAL.IS_MY_VIEWED,
    CONTENT_SINGLE_TUTORIAL.IS_MY_LIKED,
    CONTENT_SINGLE_TUTORIAL.IS_MY_FAVORITE,
    CONTENT_SINGLE_TUTORIAL.IS_MY_EXECUTED,
    CONTENT_SINGLE_TUTORIAL.IS_MY_CREATED,
    CONTENT_SINGLE_TUTORIAL.LAST_VIEWED_ON,
    CONTENT_SINGLE_TUTORIAL.LAST_EXECUTED_ON,
    CONTENT_SINGLE_TUTORIAL.EXECUTIONS,
    CONTENT_SINGLE_TUTORIAL.LIKES,
    CASE
        WHEN
            CONTENT_SINGLE_TUTORIAL.CREATED_BY = UPPER( :current_user )
            OR AU' || 'THORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_TUTORIAL.CREATED_BY
    END AS CREATED_BY,
    CASE
        WHEN
            CONTENT_SINGLE_TUTORIAL.CREATED_BY_DISPLAY_NAME IS NULL
        THEN
            CASE
                WHEN UPPER(SUBSTR(CONTENT_SINGLE_TUTORIAL.CREATED_BY, -11)) = ''@ORACLE.COM'' THEN ''Oracle''
                ELSE ''Live SQL User''
            END
        ELSE
            CONTENT_SINGLE_TUTORIAL.CREATED_BY_DISPLAY_NAME
    END AS CREATED_BY_DISPLAY_NAME,
    CONTENT_SINGLE_TUTORIAL.CREATED_ON,
    CASE
        WHEN
            CONTENT_SINGLE_TUTORIAL.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_TUTORIAL.UPDATED_BY
    END AS UPDATED_BY,
    CONTENT_SINGLE_TUTORIAL.UPDATED_BY_DISPLAY_NAME,
    CONTENT_SINGLE_TUTORIAL.UPDATED_ON,
    ''statement' || 's/'' AS "$statements"
FROM
    CONTENT_NORMALIZED_TABLE(
        P_CONTENT_LIKE_TABLE => SINGLE_TUTORIAL,
        P_CONTENT_METRICS_MV => TUTORIALS_METRICS_MV,
        P_CONTENT_USER_METRICS_TABLE => TUTORIALS_USER_METRICS,
        P_CONTENT_TYPE => ''TUTORIAL'',
        P_SELF_URI_PREFIX => NULL,
        P_CURRENT_USER => UPPER( :current_user ),
        P_INCLUDE_USER_METRICS_1_0 => 1,
        P_INCLUDE_SELF_COLUMN_1_0 => 0,
        P_SHORTEN_DESCRIPTION_1_0 => 0,
        P_INCLUDE_CONTENT_COLUMNS_1_0 => 0,
        P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
        P_INCLUDE_UPDATED_BY_COL_1_0 => 1,
        P_INCLUDE_CONT_CAT_ID_COL_1_0 => 0,
        P_INCLUDE_LEGACY_COLUMNS_1_0 => 0,
        P_ADDITIONAL_COLUMNS => COLUMNS( SETUP_CODE, SETUP_CODE_LANGUAGE, CREATED_BY, UPDATED_BY )
    ) CONTENT_SINGLE_TUTORIAL');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    -- NOTE: Check whether it''s current user''s tutorial or not
    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            TUTORIALS
        WHERE
            SLUG = :tutorial_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NO_DATA_FOUND;
    END;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES THEN
        -- NOTE: We know user is not an administrator at this point (He''s either BASIC or PUBLISHER)
        IF
            -- NO' || 'TE: Only administrators and above are allowed to change the featured column
            :is_featured IS NOT NULL
            OR (
                -- NOTE: Only publishers and above are allowed to change the published column
                :is_published IS NOT NULL
                AND ''PUBLISHER'' NOT MEMBER OF L_ROLES
            )
            OR L_IS_MY_CREATED_YN != ''Y''
        THEN
            RAISE FORBIDDEN;
        END IF;
    END IF;

    IF
        (
            :minimum_database_version IS NOT NULL
            AND NOT UTILITIES.IS_VALID_DATABASE_VERSION( :minimum_database_version )
        ) OR (
            :is_published IS NOT NULL
            AND NOT UTILITIES.IS_VALID_YN_BOOLEAN( :is_published )
        ) OR (
            :is_featured IS NOT NULL
            AND NOT UTILITIES.IS_VALID_YN_BOOLEAN( :is_featured )
        )
    THEN
        RAISE BAD_REQUEST;
    END IF;

    UPDATE
        TUTORIALS
    SET
        TITLE = NVL( :title, TITLE ),
        DESCRIPTION = NVL( :de' || 'scription, DESCRIPTION ),
        MINIMUM_DATABASE_VERSION = NVL( :minimum_database_version, MINIMUM_DATABASE_VERSION ),
        TAGS = NVL( :tags, TAGS ),
        -- NOTE: Not updating share key as that''s the job for another endpoint
        SHARE_KEY = SHARE_KEY,
        CONTENT_CATEGORY_ID = NVL( :content_category_id, CONTENT_CATEGORY_ID ),
        SETUP_CODE = :setup_code,
        SETUP_CODE_LANGUAGE = NVL( :setup_code_language, SETUP_CODE_LANGUAGE ),
        IS_PUBLISHED = NVL( :is_published, IS_PUBLISHED ),
        IS_FEATURED = NVL( :is_featured, IS_FEATURED ),
        UPDATED_BY = L_CURRENT_USER,
        UPDATED_ON = CURRENT_TIMESTAMP
    WHERE
        ID = L_ID;
    :status_code := 200;
    :forward_location := :tutorial_slug || ''/'';
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_c' || 'ode := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    -- NOTE: Check whether it''s current user''s tutorial or not
    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            TUTORIALS
        WHERE
            SLUG = :tutorial_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES
        AND L_IS_MY_CREATED_YN != ''Y''
    THEN
        RAISE FORBIDDEN;
    END IF;

    DELETE FROM TUTORIALS WHERE ID = L_ID;
  ' || '  :status_code := 204;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    TUTORIALS_STEPS.ID,
    TUTORIALS_STEPS.LEGACY_ID,
    TUTORIALS_STEPS.SEQUENCE,
    TUTORIALS_STEPS.TITLE,
    TUTORIALS_STEPS.CONTENT,
    TUTORIALS_STEPS.FORMAT,
    CASE
        WHEN
            TUTORIALS_STEPS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            TUTORIALS_STEPS.CREATED_BY
    END AS CREATED_BY,
    CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
    TUTORIALS_STEPS.CREATED_ON,
    CASE
        WHEN
            TUTORIALS_STEPS.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            TUTORIALS_STEPS.UPDATED_BY
    END AS UPDATED_BY,
    UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME,
    TUTORIALS_STEPS.UPDATED_ON,
    TUTORIALS_STEPS.ID AS "$self",
    ''../'' AS "$tutorial"
FROM
    TUTORIALS_STE' || 'PS JOIN TUTORIALS ON
        TUTORIALS.SLUG = :tutorial_slug
        AND (
            TUTORIALS.IS_PUBLISHED = ''Y''
            OR TUTORIALS.CREATED_BY = UPPER( :current_user )
            OR TUTORIALS.SHARE_KEY = :share_key
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        )
        AND TUTORIALS_STEPS.TUTORIAL_ID = TUTORIALS.ID
    LEFT JOIN USERS CREATED_BY_DISPLAY_NAMES ON
        TUTORIALS_STEPS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
    LEFT JOIN USERS UPDATED_BY_DISPLAY_NAMES ON
        TUTORIALS_STEPS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    L_STEP_ID NUMBER;

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            TUTORIALS
        WHERE
            SLUG = :tutorial_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES
        AND L_IS_MY_CREATED_YN != ''Y''
    THEN
        RAISE FORBIDDEN;
    END IF;

    INSERT INTO TUTORIALS_STEPS (
        TUTORIAL_ID,
        SEQUENCE,
        TITL' || 'E,
        CONTENT,
        CREATED_BY,
        UPDATED_BY,
        UPDATED_ON
    ) VALUES (
        L_ID,
        :sequence,
        :title,
        :content,
        L_CURRENT_USER,
        NULL,
        NULL
    ) RETURNING ID INTO L_STEP_ID;

    UPDATE TUTORIALS
    SET
        UPDATED_ON = CURRENT_TIMESTAMP
    WHERE
        SLUG = :tutorial_slug;

    :status_code := 201;
    :forward_location := L_STEP_ID;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR' || '_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    STEPS_TO_REORDER JSON_ARRAY_T;
    STEPS_OBJECT JSON_OBJECT_T;
    FIRST_BODY_CHARACTER CLOB;
    BODY_HOLDER CLOB := :body_text;
    STEPS_ID NUMBER;
    STEPS_SEQUENCE NUMBER;

    UNAUTHORIZED EXCEPTION;
    BAD_REQUEST EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
       RAISE UNAUTHORIZED;
    END IF;

    -- This takes the first character in the body: If it''s [, then it''s an array and it''s meant to be
    -- for reordering, otherwise it would be for saving the script results
    FIRST_BODY_CHARACTER := DBMS_LOB.SUBSTR(BODY_HOLDER, 1, 1);

    IF FIRST_BODY_CHARACTER = TO_CLOB(''['') THEN
        STEPS_TO_REORDER := JSON_ARRAY_T.PARSE(BODY_HOLDER);
        FOR i IN 0..STEPS_TO_REORDER.GET_SIZE - 1 LOOP
            STEPS_OBJECT := TREAT(STEPS_TO_REORDER.get(i) AS JSON_OBJECT_T);
            STEPS_SEQUENCE := STEPS_OBJECT.GET_NUMBER(''sequence'');
            STEPS_ID := ST' || 'EPS_OBJECT.GET_NUMBER(''id'');
            UPDATE 
                TUTORIALS_STEPS 
            SET
                TUTORIALS_STEPS.SEQUENCE = NVL(STEPS_SEQUENCE, TUTORIALS_STEPS.SEQUENCE)
            WHERE
                TUTORIALS_STEPS.ID = STEPS_ID;
        END LOOP;
    ELSE
        RAISE BAD_REQUEST;
    END IF;
    :status_code := 201;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_SLUG SCRIPTS.SLUG%TYPE;

    UNAUTHORIZED EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        RAISE UNAUTHORIZED;
    END IF;

    INSERT INTO SCRIPTS (
        TITLE,
        DESCRIPTION,
        MINIMUM_DATABASE_VERSION,
        TAGS,
        SHARE_KEY,
        CONTENT_CATEGORY_ID,
        SLUG,
        IS_PUBLISHED,
        IS_FEATURED,
        LEGACY_ID,
        LEGACY_FILE_NAME,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    ) VALUES (
        :title,
        :description,
        :minimum_database_version,
        :tags,
        NULL,
        NULL,
        NULL,
        ''N'',
        ''N'',
        NULL,
        NULL,
        L_CURRENT_USER,
        NULL,
        L_CURRENT_USER,
        NULL
    ) RETURNING SLUG INTO L_SLUG;
    :status_code := 201;
    :forward_location := L_SLUG  || ''/'';
EXCEPTION
    -- TODO: Log SQLERRM to a l' || 'ogging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'me',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'me',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    USERS.EMAIL,
    USERS.DISPLAY_NAME,
    ROLES.NAME AS ROLE
 FROM
    USERS JOIN ROLES ON
        USERS.EMAIL = :current_user
        AND USERS.ROLE_ID = ROLES.ID');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'me',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_URL VARCHAR2(4000) := GET_PARAMETER( ''IDCS_URL'' );
    L_CLIENT_ID VARCHAR2(512) := UTILITIES.HEX_DECRYPT( GET_PARAMETER( ''IDCS_CLIENT_ID'' ) );
    L_CLIENT_SECRET VARCHAR2(512) := UTILITIES.HEX_DECRYPT( GET_PARAMETER( ''IDCS_CLIENT_SECRET'' ) );
    L_WALLET_PATH VARCHAR2(4000) := NULL;

    L_RESPONSE CLOB;

    BAD_REQUEST EXCEPTION; 
    UNAUTHORIZED EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        RAISE UNAUTHORIZED;
    END IF;

    IF :refresh_token IS NULL THEN
        RAISE BAD_REQUEST;
    END IF;

    UPDATE SCHEMAS
    SET
        STATUS = ''DROPPING'',
        ASSIGNED_TO = NULL
    WHERE
        ASSIGNED_TO = L_CURRENT_USER;

    DELETE FROM USERS WHERE EMAIL = L_CURRENT_USER;

    -- NOTE: If we get to this point we will return a 200 even if the refresh
    --       token doesn''t get revoked because the next time we try to do this
    --       the user wi' || 'll no longer exist and this endpoint will fail anyway

    BEGIN
        IF DOES_PARAMETER_EXIST( ''WALLET_PATH'' ) THEN
            L_WALLET_PATH := GET_PARAMETER( ''WALLET_PATH'' );
        END IF;

        APEX_WEB_SERVICE.SET_REQUEST_HEADERS(
            P_NAME_01 => ''Content-Type'',
            P_VALUE_01 => ''application/x-www-form-urlencoded'',
            P_RESET => TRUE
        );
        -- Begin the request to revoke the refresh_token
        L_RESPONSE := APEX_WEB_SERVICE.MAKE_REST_REQUEST(
            P_URL => L_URL || ''/oauth2/v1/revoke'',
            P_HTTP_METHOD => ''POST'',
            P_USERNAME => L_CLIENT_ID,
            P_PASSWORD => L_CLIENT_SECRET,
            P_BODY => ''token='' || :refresh_token,
            P_WALLET_PATH => L_WALLET_PATH
        );

        IF APEX_WEB_SERVICE.G_STATUS_CODE != 200 THEN
            RAISE_APPLICATION_ERROR( -20000, ''Refresh token could not be revoked. Call returned with HTTP status code: '' || APEX_WEB_SERVICE.G_STATUS_CODE );
        END ' || 'IF;
    EXCEPTION
        -- TODO: Log SQLERRM to a logging table
        -- TODO: Save refresh_token to remove it at a later stage
        -- NOTE: Allow this to fail because there cannot be a nest run for this
        --       endpoint
        WHEN OTHERS THEN
            NULL;
    END;

    :status_code := 204;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/:step_id',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/:step_id',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_CURRENT_ROLES THEN
        DECLARE
            L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
        BEGIN
            SELECT 
                CASE WHEN COUNT(1) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_RECORD_YN
            FROM 
                TUTORIALS_STEPS LEFT JOIN TUTORIALS 
                    ON TUTORIALS_STEPS.TUTORIAL_ID = TUTORIALS.ID
            WHERE
                TUTORIALS.SLUG = :tutorial_slug
                AND TUTORIALS_STEPS.ID = :step_id
                AND TUTORIALS_STEPS.CREATED_BY = L_CURRENT_USER;

            IF L_IS_OWN_RECORD_YN = ''N'' THEN
                :status_code := 404;
                RETURN;
            END IF;
        END;
    ' || 'END IF;

    DELETE FROM TUTORIALS_STEPS WHERE ID = :step_id;
    :status_code := 204;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/:step_id',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    TUTORIALS_STEPS.ID,
    TUTORIALS_STEPS.SEQUENCE,
    TUTORIALS_STEPS.TITLE,
    TUTORIALS_STEPS.CONTENT,
    TUTORIALS_STEPS.FORMAT,
    CASE
        WHEN
            TUTORIALS_STEPS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            TUTORIALS_STEPS.CREATED_BY
    END AS CREATED_BY,
    CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
    TUTORIALS_STEPS.CREATED_ON,
    CASE
        WHEN
            TUTORIALS_STEPS.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            TUTORIALS_STEPS.UPDATED_BY
    END AS UPDATED_BY,
    UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME,
    TUTORIALS_STEPS.UPDATED_ON,
    TUTORIALS_STEPS.ID AS "$self",
    ''../'' AS "$tutorial"
FROM
    TUTORIALS_STEPS JOIN TUTORIALS ON
        TU' || 'TORIALS.SLUG = :tutorial_slug
        AND (
            TUTORIALS.IS_PUBLISHED = ''Y''
            OR TUTORIALS.CREATED_BY = UPPER( :current_user )
            OR TUTORIALS.SHARE_KEY = :share_key
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        )
        AND TUTORIALS_STEPS.TUTORIAL_ID = TUTORIALS.ID
    LEFT JOIN USERS CREATED_BY_DISPLAY_NAMES ON
        TUTORIALS_STEPS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
    LEFT JOIN USERS UPDATED_BY_DISPLAY_NAMES ON
        TUTORIALS_STEPS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL
WHERE
    TUTORIALS_STEPS.ID = :step_id');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'tutorials/:tutorial_slug/steps/:step_id',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
    L_IS_ADMIN VARCHAR2(1) := ''N'';
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    -- check if the user is an admin
    IF ''ADMINISTRATOR'' MEMBER OF L_CURRENT_ROLES THEN
        L_IS_ADMIN := ''Y'';
    END IF;

    IF L_IS_ADMIN = ''N'' THEN
        DECLARE
            L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
        BEGIN
            SELECT 
                CASE WHEN COUNT(1) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_RECORD_YN
            FROM 
                TUTORIALS_STEPS LEFT JOIN TUTORIALS 
                    ON TUTORIALS_STEPS.TUTORIAL_ID = TUTORIALS.ID
            WHERE
                TUTORIALS.SLUG = :tutorial_slug
                AND TUTORIALS_STEPS.ID = :step_id
                AND TUTORIALS_STEPS.CREATED_BY = L_CURRENT_USER;

      ' || '      IF L_IS_OWN_RECORD_YN = ''N'' THEN
                :status_code := 404; 
                RETURN;
            END IF;
        END;

        -- update for non-admin users (script_owner)
        UPDATE TUTORIALS_STEPS
        SET
            SEQUENCE = :sequence,
            TITLE = NVL(:title, TITLE),
            CONTENT = :content,
            FORMAT = :format,
            UPDATED_BY = L_CURRENT_USER, 
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            ID = :step_id;

        UPDATE TUTORIALS
        SET
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            SLUG = :tutorial_slug;
    ELSE
        -- update for admin users (can change all details)
        UPDATE TUTORIALS_STEPS
        SET
            SEQUENCE = :sequence,
            TITLE = NVL(:title, TITLE),
            CONTENT = :content,
            FORMAT = :format,
            CREATED_BY = NVL(:created_by, CREATED_BY), -- admin can update CREATED_BY
            UPDATED_BY = L_CURRENT_USER, 
  ' || '          UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            ID = :step_id;

        UPDATE TUTORIALS
        SET
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            SLUG = :tutorial_slug;
    END IF;

    :status_code := 200;
    :forward_location := :step_id;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    -- NOTE: Check whether it''s current user''s script or not
    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            SCRIPTS
        WHERE
            SLUG = :script_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NO_DATA_FOUND;
    END;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES THEN
        -- NOTE: We know user is not an administrator at this point (He''s either BASIC or PUBLISHER)
        IF
            -- NOTE: On' || 'ly administrators and above are allowed to change the featured column
            :is_featured IS NOT NULL
            OR (
                -- NOTE: Only publishers and above are allowed to change the published column
                :is_published IS NOT NULL
                AND ''PUBLISHER'' NOT MEMBER OF L_ROLES
            )
            OR L_IS_MY_CREATED_YN != ''Y''
        THEN
            RAISE FORBIDDEN;
        END IF;
    END IF;

    IF
        (
            :minimum_database_version IS NOT NULL
            AND NOT UTILITIES.IS_VALID_DATABASE_VERSION( :minimum_database_version )
        ) OR (
            :is_published IS NOT NULL
            AND NOT UTILITIES.IS_VALID_YN_BOOLEAN( :is_published )
        ) OR (
            :is_featured IS NOT NULL
            AND NOT UTILITIES.IS_VALID_YN_BOOLEAN( :is_featured )
        )
    THEN
        RAISE BAD_REQUEST;
    END IF;

    UPDATE
        SCRIPTS
    SET
        TITLE = NVL( :title, TITLE ),
        DESCRIPTION = NVL( :descriptio' || 'n, DESCRIPTION ),
        MINIMUM_DATABASE_VERSION = NVL( :minimum_database_version, MINIMUM_DATABASE_VERSION ),
        TAGS = NVL( :tags, TAGS ),
        -- NOTE: Not updating share key as that''s the job for another endpoint
        SHARE_KEY = SHARE_KEY,
        CONTENT_CATEGORY_ID = NVL( :content_category_id, CONTENT_CATEGORY_ID ),
        IS_PUBLISHED = NVL( :is_published, IS_PUBLISHED ),
        IS_FEATURED = NVL( :is_featured, IS_FEATURED ),
        UPDATED_BY = L_CURRENT_USER,
        UPDATED_ON = CURRENT_TIMESTAMP
    WHERE
        ID = L_ID;
    :status_code := 200;
    :forward_location := :script_slug || ''/'';
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status' || '_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    -- NOTE: Check whether it''s current user''s script or not
    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            SCRIPTS
        WHERE
            SLUG = :script_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES
        AND L_IS_MY_CREATED_YN != ''Y''
    THEN
        RAISE FORBIDDEN;
    END IF;

    DELETE FROM SCRIPTS WHERE ID = L_ID;
    :statu' || 's_code := 204;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID SCRIPTS.ID%TYPE;
    L_IS_PUBLISHED_YN VARCHAR2(1);
    L_IS_SHARED_YN VARCHAR2(1);
    L_IS_MATCHING_SHARE_KEY_YN VARCHAR2(1);
    L_IS_MY_CREATED_YN VARCHAR2(1);

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF
        :action IS NULL
        OR (
            NOT UTILITIES.IS_VALID_CONENT_ACTION( :action )
            AND :action NOT IN ( ''UNLIKE'', ''UNFAVORITE'', ''SHARE'', ''UNSHARE'' )
        )
    THEN
        RAISE BAD_REQUEST;
    END IF;

    BEGIN
        SELECT
            ID,
            IS_PUBLISHED,
            CASE WHEN SHARE_KEY IS NOT NULL THEN ''Y'' ELSE ''N'' END AS IS_SHARED,
            CASE WHEN SHARE_KEY IS NOT NULL AND SHARE_KEY = :share_key THEN ''Y'' ELSE ''N'' END AS IS_MATCHING_SHARE_KEY,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_' || 'IS_PUBLISHED_YN,
            L_IS_SHARED_YN,
            L_IS_MATCHING_SHARE_KEY_YN,
            L_IS_MY_CREATED_YN
        FROM
            SCRIPTS
        WHERE
            SLUG = :script_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        L_CURRENT_USER IS NULL
        AND :action NOT IN ( ''VIEW'', ''EXECUTE'' )
    THEN
        RAISE UNAUTHORIZED;
    END IF;

    IF
        -- NOTE: Administrators don''t get to register an action if the
        --       script isn''t public, shared or doesn''t belong to them
        (
            L_CURRENT_USER IS NOT NULL
            AND NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' )
        ) OR (
            :action IN ( ''SHARE'', ''UNSHARE'' )
            AND L_IS_MY_CREATED_YN != ''Y''
        ) OR (
            L_IS_PUBLISHED_YN != ''Y''
            AND L_IS_MY_CREATED_YN != ''Y''
            AND L_IS_MATCHING_SHARE_KEY_YN != ''Y''
        )
    THEN
        RAISE FORBIDDEN;
    END IF;

    IF :ac' || 'tion IN ( ''UNLIKE'', ''UNFAVORITE'' ) THEN
        -- NOTE: Doesn''t matter if it doesn''t exist
        DELETE
        FROM
            SCRIPTS_METRICS
        WHERE
            ACTION = CASE :action
                WHEN ''UNLIKE'' THEN
                    ''LIKE''
                WHEN ''UNFAVORITE'' THEN
                    ''FAVORITE''
            END
            AND SCRIPT_ID = L_ID;

        :status_code := 204;
        RETURN;
    END IF;

    IF :action IN ( ''SHARE'', ''UNSHARE'' ) THEN
        -- NOTE: Doesn''t matter if it doesn''t exist
        UPDATE
            SCRIPTS
        SET
            SHARE_KEY = CASE :action WHEN ''SHARE'' THEN UTILITIES.GET_SHARE_KEY() END
        WHERE
            ID = L_ID;

        :status_code := 200;
        :forward_location := :script_slug || ''/'';
        RETURN;
    END IF;

    INSERT INTO SCRIPTS_METRICS (
        SCRIPT_ID,
        ACTION,
        CREATED_BY
    ) VALUES (
        L_ID,
        :action,
        L_CURRENT_USER
    );
    :status_code := 204' || ';
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    SINGLE_SCRIPT AS (
        SELECT
            SCRIPTS.*,
            CREATED_BY_USERS.DISPLAY_NAME AS CREATED_BY_DISPLAY_NAME,
            UPDATED_BY_USERS.DISPLAY_NAME AS UPDATED_BY_DISPLAY_NAME
        FROM
            SCRIPTS LEFT JOIN USERS CREATED_BY_USERS ON
                SCRIPTS.CREATED_BY = CREATED_BY_USERS.EMAIL
            LEFT JOIN USERS UPDATED_BY_USERS ON
                SCRIPTS.UPDATED_BY = UPDATED_BY_USERS.EMAIL
        WHERE
            SCRIPTS.SLUG = :script_slug
            AND (
                IS_PUBLISHED = ''Y''
                OR CREATED_BY = UPPER( :current_user )
                OR SHARE_KEY = :share_key
                OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
            )
    )
SELECT
    -- CONTENT_SINGLE_SCRIPT.ID,
    CONTENT_SINGLE_SCRIPT.TITLE,
    CONTENT_SINGLE_SCRIPT.DESCRIPTION,
    CONTENT_SINGLE_SCRIPT.MINIMUM_DATABASE_VERSION,
    CONTENT_SINGLE_SCRIPT.TAGS,
    CASE
        WHEN
 ' || '           CONTENT_SINGLE_SCRIPT.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_SCRIPT.SHARE_KEY
    END AS SHARE_KEY,
    -- CONTENT_SINGLE_SCRIPT.CONTENT_CATEGORY_ID,
    CONTENT_SINGLE_SCRIPT.SLUG,
    CONTENT_SINGLE_SCRIPT.IS_PUBLISHED,
    CONTENT_SINGLE_SCRIPT.IS_FEATURED,
    CONTENT_SINGLE_SCRIPT.IS_MY_VIEWED,
    CONTENT_SINGLE_SCRIPT.IS_MY_LIKED,
    CONTENT_SINGLE_SCRIPT.IS_MY_FAVORITE,
    CONTENT_SINGLE_SCRIPT.IS_MY_EXECUTED,
    CONTENT_SINGLE_SCRIPT.IS_MY_CREATED,
    CONTENT_SINGLE_SCRIPT.LAST_VIEWED_ON,
    CONTENT_SINGLE_SCRIPT.LAST_EXECUTED_ON,
    CONTENT_SINGLE_SCRIPT.EXECUTIONS,
    CONTENT_SINGLE_SCRIPT.FAVORITES,
    CONTENT_SINGLE_SCRIPT.LIKES,
    CASE
        WHEN
            CONTENT_SINGLE_SCRIPT.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''AD' || 'MINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_SCRIPT.CREATED_BY
    END AS CREATED_BY,
    CASE
        WHEN
            CONTENT_SINGLE_SCRIPT.CREATED_BY_DISPLAY_NAME IS NULL
        THEN
            CASE
                WHEN UPPER(SUBSTR(CONTENT_SINGLE_SCRIPT.CREATED_BY, -11)) = ''@ORACLE.COM'' THEN ''Oracle''
                ELSE ''Live SQL User''
            END
        ELSE
            CONTENT_SINGLE_SCRIPT.CREATED_BY_DISPLAY_NAME
    END AS CREATED_BY_DISPLAY_NAME,
    CONTENT_SINGLE_SCRIPT.CREATED_ON,
    CASE
        WHEN
            CONTENT_SINGLE_SCRIPT.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT_SINGLE_SCRIPT.UPDATED_BY
    END AS UPDATED_BY,
    CONTENT_SINGLE_SCRIPT.UPDATED_BY_DISPLAY_NAME,
    CONTENT_SINGLE_SCRIPT.UPDATED_ON,
    ''statements/'' AS "$statements"
FROM
    CONTENT_NORMALIZED_TABLE(
        P_CONTENT_LIKE_TABLE => SIN' || 'GLE_SCRIPT,
        P_CONTENT_METRICS_MV => SCRIPTS_METRICS_MV,
        P_CONTENT_USER_METRICS_TABLE => SCRIPTS_USER_METRICS,
        P_CONTENT_TYPE => ''SCRIPT'',
        P_SELF_URI_PREFIX => NULL,
        P_CURRENT_USER => UPPER( :current_user ),
        P_INCLUDE_USER_METRICS_1_0 => 1,
        P_INCLUDE_SELF_COLUMN_1_0 => 0,
        P_SHORTEN_DESCRIPTION_1_0 => 0,
        P_INCLUDE_CONTENT_COLUMNS_1_0 => 0,
        P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
        P_INCLUDE_UPDATED_BY_COL_1_0 => 1,
        P_INCLUDE_CONT_CAT_ID_COL_1_0 => 0,
        P_INCLUDE_LEGACY_COLUMNS_1_0 => 0,
        P_ADDITIONAL_COLUMNS => COLUMNS( CREATED_BY, UPDATED_BY )
    ) CONTENT_SINGLE_SCRIPT');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    L_STATEMENT_ID NUMBER;

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            SCRIPTS
        WHERE
            SLUG = :script_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        ''ADMINISTRATOR'' NOT MEMBER OF L_ROLES
        AND L_IS_MY_CREATED_YN != ''Y''
    THEN
        RAISE FORBIDDEN;
    END IF;

    INSERT INTO SCRIPTS_STATEMENTS (
        SCRIPT_ID,
        SEQUENCE,
        TI' || 'TLE,
        CONTENT,
        EXPECTED_RESULT,
        CREATED_BY,
        UPDATED_BY,
        UPDATED_ON
    ) VALUES (
        L_ID,
        :sequence,
        :title,
        :content,
        :expected_result,
        L_CURRENT_USER,
        NULL,
        NULL
    ) RETURNING ID INTO L_STATEMENT_ID;

    UPDATE SCRIPTS
    SET
        UPDATED_ON = CURRENT_TIMESTAMP
    WHERE
        SLUG = :script_slug;

    :status_code := 201;
    :forward_location := L_STATEMENT_ID;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OT' || 'HERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    statements_results_list_object JSON_OBJECT_T;
    statements_results_list JSON_ARRAY_T;
    statements_ids_list JSON_ARRAY_T;
    statement_result JSON_OBJECT_T;
    statements_to_insert JSON_ARRAY_T := JSON_ARRAY_T();
    statements_to_reorder JSON_ARRAY_T;
    statement_object JSON_OBJECT_T;
    clob_statement CLOB;
    first_body_character CLOB;
    body_holder CLOB := :body_text;
    statement_id number;
    statement_sequence number;

    UNAUTHORIZED EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
       RAISE UNAUTHORIZED;
    END IF;

    -- This takes the first character in the body: If it''s [, then it''s an array and it''s meant to be
    -- for reordering, otherwise it would be for saving the script results
    first_body_character := DBMS_LOB.SUBSTR(body_holder, 1, 1);

    IF first_body_character = TO_CLOB(''['') THEN
        statements_to_reorder := JSON_ARRAY_T.pa' || 'rse(body_holder);
        FOR i IN 0..statements_to_reorder.get_size - 1 LOOP
            statement_object := TREAT(statements_to_reorder.get(i) as JSON_OBJECT_T);
            statement_sequence := statement_object.get_number(''sequence'');
            statement_id := statement_object.get_number(''id'');
            UPDATE 
                SCRIPTS_STATEMENTS 
            SET
                SCRIPTS_STATEMENTS.SEQUENCE = NVL(statement_sequence, SCRIPTS_STATEMENTS.SEQUENCE)
            WHERE
                SCRIPTS_STATEMENTS.ID = statement_id;
        END LOOP;
    ELSE
        statements_results_list_object := JSON_OBJECT_T.parse(body_holder);
        statements_results_list := statements_results_list_object.get_array(''statements_results'');
        statements_ids_list := statements_results_list_object.get_array(''statements_ids'');

        FOR ind IN 0..statements_results_list.get_size - 1
        LOOP
            statement_result := TREAT(statements_results_list.get(ind) as JSON_OBJECT_T);' || '
            statements_to_insert.APPEND(statement_result);
        END LOOP;

        FOR id in 0..statements_ids_list.get_size - 1
        LOOP
            clob_statement := statements_to_insert.get(id).to_clob;
            statement_id := statements_ids_list.get(id).to_number;
            UPDATE 
                SCRIPTS_STATEMENTS 
            SET
                EXPECTED_RESULT = clob_statement
            WHERE
                ID = statement_id;
        END LOOP;
    END IF;
    :status_code := 201;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    SCRIPTS_STATEMENTS.ID,
    SCRIPTS_STATEMENTS.LEGACY_ID,
    SCRIPTS_STATEMENTS.SEQUENCE,
    SCRIPTS_STATEMENTS.TITLE,
    SCRIPTS_STATEMENTS.CONTENT,
    SCRIPTS_STATEMENTS.EXPECTED_RESULT,
    CASE
        WHEN
            SCRIPTS_STATEMENTS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            SCRIPTS_STATEMENTS.CREATED_BY
    END AS CREATED_BY,
    CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
    SCRIPTS_STATEMENTS.CREATED_ON,
    CASE
        WHEN
            SCRIPTS_STATEMENTS.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            SCRIPTS_STATEMENTS.UPDATED_BY
    END AS UPDATED_BY,
    UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME,
    SCRIPTS_STATEMENTS.UPDATED_ON,
    SCRIPTS_STATEMENTS.ID AS "$self",' || '
    ''../'' AS "$script"
FROM
    SCRIPTS_STATEMENTS JOIN SCRIPTS ON
        SCRIPTS.SLUG = :script_slug
        AND (
            SCRIPTS.IS_PUBLISHED = ''Y''
            OR SCRIPTS.CREATED_BY = UPPER( :current_user )
            OR SCRIPTS.SHARE_KEY = :share_key
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        )
        AND SCRIPTS_STATEMENTS.SCRIPT_ID = SCRIPTS.ID
    LEFT JOIN USERS CREATED_BY_DISPLAY_NAMES ON
        SCRIPTS_STATEMENTS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
    LEFT JOIN USERS UPDATED_BY_DISPLAY_NAMES ON
        SCRIPTS_STATEMENTS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/:statement_id',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/:statement_id',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    SCRIPTS_STATEMENTS.ID,
    SCRIPTS_STATEMENTS.SEQUENCE,
    SCRIPTS_STATEMENTS.TITLE,
    SCRIPTS_STATEMENTS.CONTENT,
    SCRIPTS_STATEMENTS.EXPECTED_RESULT,
    CASE
        WHEN
            SCRIPTS_STATEMENTS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            SCRIPTS_STATEMENTS.CREATED_BY
    END AS CREATED_BY,
    CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
    SCRIPTS_STATEMENTS.CREATED_ON,
    CASE
        WHEN
            SCRIPTS_STATEMENTS.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            SCRIPTS_STATEMENTS.UPDATED_BY
    END AS UPDATED_BY,
    UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME,
    SCRIPTS_STATEMENTS.UPDATED_ON,
    SCRIPTS_STATEMENTS.ID AS "$self",
    ''../'' AS "$script"
FROM
    S' || 'CRIPTS_STATEMENTS JOIN SCRIPTS ON
        SCRIPTS.SLUG = :script_slug
        AND (
            SCRIPTS.IS_PUBLISHED = ''Y''
            OR SCRIPTS.CREATED_BY = UPPER( :current_user )
            OR SCRIPTS.SHARE_KEY = :share_key
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        )
        AND SCRIPTS_STATEMENTS.SCRIPT_ID = SCRIPTS.ID
    LEFT JOIN USERS CREATED_BY_DISPLAY_NAMES ON
        SCRIPTS_STATEMENTS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
    LEFT JOIN USERS UPDATED_BY_DISPLAY_NAMES ON
        SCRIPTS_STATEMENTS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL
WHERE
    SCRIPTS_STATEMENTS.ID = :statement_id');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/:statement_id',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
    L_IS_ADMIN VARCHAR2(1) := ''N'';
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    -- check if the user is an admin
    IF ''ADMINISTRATOR'' MEMBER OF L_CURRENT_ROLES THEN
        L_IS_ADMIN := ''Y'';
    END IF;

    IF L_IS_ADMIN = ''N'' THEN
        DECLARE
            L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
        BEGIN
            SELECT 
                CASE WHEN COUNT(1) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_RECORD_YN
            FROM 
                SCRIPTS_STATEMENTS LEFT JOIN SCRIPTS 
                    ON SCRIPTS_STATEMENTS.SCRIPT_ID = SCRIPTS.ID
            WHERE
                SCRIPTS.SLUG = :script_slug
                AND SCRIPTS_STATEMENTS.ID = :statement_id
                AND SCRIPTS_STATEMENTS.CREATED_BY = L_CURRENT_USER;
' || '
            IF L_IS_OWN_RECORD_YN = ''N'' THEN
                :status_code := 404; 
                RETURN;
            END IF;
        END;

        -- update for non-admin users (script_owner)
        UPDATE SCRIPTS_STATEMENTS
        SET
            SEQUENCE = :sequence,
            TITLE = NVL(:title, TITLE),
            CONTENT = :content,
            UPDATED_BY = L_CURRENT_USER, 
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            ID = :statement_id;

        UPDATE SCRIPTS
        SET
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            SLUG = :script_slug;
    ELSE
        -- update for admin users (can change all details)
        UPDATE SCRIPTS_STATEMENTS
        SET
            SEQUENCE = :sequence,
            TITLE = NVL(:title, TITLE),
            CONTENT = :content,
            CREATED_BY = NVL(:created_by, CREATED_BY), -- admin can update CREATED_BY
            UPDATED_BY = L_CURRENT_USER, 
            UPDATED_ON = CURRENT_TIMESTAMP
     ' || '   WHERE
            ID = :statement_id;

        UPDATE SCRIPTS
        SET
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            SLUG = :script_slug;
    END IF;

    :status_code := 200;
    :forward_location := :statement_id;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/:statement_id',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
BEGIN
    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_CURRENT_ROLES THEN
        DECLARE
            L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
        BEGIN
            SELECT 
                CASE WHEN COUNT(1) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_RECORD_YN
            FROM 
                SCRIPTS_STATEMENTS LEFT JOIN SCRIPTS 
                    ON SCRIPTS_STATEMENTS.SCRIPT_ID = SCRIPTS.ID
            WHERE
                SCRIPTS.SLUG = :script_slug
                AND SCRIPTS_STATEMENTS.ID = :statement_id
                AND SCRIPTS_STATEMENTS.CREATED_BY = L_CURRENT_USER;

            IF L_IS_OWN_RECORD_YN = ''N'' THEN
                :status_code := 404;
                RETURN;
            END IF;
        EN' || 'D;
    END IF;

    DELETE FROM SCRIPTS_STATEMENTS WHERE ID = :statement_id;
    :status_code := 204;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'content/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'content/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    FILTERED_TUTORIALS AS (
        SELECT
            *
        FROM
            TUTORIALS
        WHERE
            TUTORIALS.IS_PUBLISHED = ''Y''
            OR TUTORIALS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
    ),
    NON_SEARCH_TUTORIALS AS (
        SELECT
            FILTERED_TUTORIALS.*,
            NULL AS SEARCH_SCORE
        FROM
            FILTERED_TUTORIALS
        WHERE
            :search IS NULL
    ),
    SEARCH_TUTORIALS AS (
        SELECT 
            FILTERED_TUTORIALS.*,
            ROUND( ( SCORE(1) + SCORE(2) + SCORE(3) + SCORE(4) + SCORE(5) ) / 5 ) AS SEARCH_SCORE
        FROM
            FILTERED_TUTORIALS
        WHERE
            :search IS NOT NULL
            AND (
                CONTAINS( FILTERED_TUTORIALS.TITLE, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 1 ) > 0
                OR CONTAINS( FILTERED_TUTORIALS.DESCRIPTION, UTILITIES.STRI' || 'NG_TO_CONTAINS_QUERY( :search ), 2 ) > 0
                OR CONTAINS( FILTERED_TUTORIALS.TAGS, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 3 ) > 0
                OR CONTAINS( FILTERED_TUTORIALS.SETUP_DESCRIPTION, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 4 ) > 0
                OR CONTAINS( FILTERED_TUTORIALS.SETUP_CODE, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 5 ) > 0
            )
    ),
    TUTORIALS_UNION AS (
        -- NOTE: Despite the fact that this could have been done using
        --       the CONTENT_ITEMS view, the SEARCH_SCORE cannot be
        --       calculated there because the scope of the query isn''t
        --       at the same level as the CONTAINS condition

        -- NOTE: This query is split in two parts. The first makes use
        --       of the text indexes in tutorials and the second only
        --       executes the query without the search. If this is not
        --       done this way, the query cost goes up because it
        --       ' || 'doesn''t use the text indexes. In this case, only one of
        --       the two queries will be executed
        SELECT * FROM NON_SEARCH_TUTORIALS
        UNION ALL
        SELECT * FROM SEARCH_TUTORIALS
    ),
    FILTERED_SCRIPTS AS (
        SELECT
            *
        FROM
            SCRIPTS
        WHERE
            SCRIPTS.IS_PUBLISHED = ''Y''
            OR SCRIPTS.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
    ),
    NON_SEARCH_SCRIPTS AS (
        SELECT
            FILTERED_SCRIPTS.*,
            NULL AS SEARCH_SCORE
        FROM
            FILTERED_SCRIPTS
        WHERE
            :search IS NULL
    ),
    SEARCH_SCRIPTS AS (
        SELECT 
            FILTERED_SCRIPTS.*,
            ROUND( ( SCORE(1) + SCORE(2) + SCORE(3) ) / 3 ) AS SEARCH_SCORE
        FROM
            FILTERED_SCRIPTS
        WHERE
            :search IS NOT NULL
            AND (
                ' || 'CONTAINS( FILTERED_SCRIPTS.TITLE, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 1 ) > 0
                OR CONTAINS( FILTERED_SCRIPTS.DESCRIPTION, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 2 ) > 0
                OR CONTAINS( FILTERED_SCRIPTS.TAGS, UTILITIES.STRING_TO_CONTAINS_QUERY( :search ), 3 ) > 0
            )
    ),
    SCRIPTS_UNION AS (
        -- NOTE: Despite the fact that this could have been done using
        --       the CONTENT_ITEMS view, the SEARCH_SCORE cannot be
        --       calculated there because the scope of the query isn''t
        --       at the same level as the CONTAINS condition

        -- NOTE: This query is split in two parts. The first makes use
        --       of the text indexes in sCRIPTs and the second only
        --       executes the query without the search. If this is not
        --       done this way, the query cost goes up because it
        --       doesn''t use the text indexes. In this case, only one of
        --       the two ' || 'queries will be executed
        SELECT * FROM NON_SEARCH_SCRIPTS
        UNION ALL
        SELECT * FROM SEARCH_SCRIPTS
    )
SELECT
    CONTENT."$self",
    CONTENT.CONTENT_TYPE,
    -- CONTENT.CONTENT_ID,
    CONTENT.TITLE,
    CONTENT.DESCRIPTION,
    CONTENT.MINIMUM_DATABASE_VERSION,
    CONTENT.TAGS,
    CASE
        WHEN
            CONTENT.CREATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT.SHARE_KEY
    END AS SHARE_KEY,
    CONTENT.SLUG,
    CONTENT.IS_PUBLISHED,
    CONTENT.IS_FEATURED,
    CONTENT.IS_SHARED,
    CONTENT.IS_MY_VIEWED,
    CONTENT.IS_MY_LIKED,
    CONTENT.IS_MY_FAVORITE,
    CONTENT.IS_MY_EXECUTED,
    CONTENT.IS_MY_CREATED,
    CONTENT.EXECUTIONS,
    CONTENT.FAVORITES,
    CONTENT.LIKES,
    CONTENT.LAST_VIEWED_ON,
    CONTENT.LAST_EXECUTED_ON,
    CASE
        WHEN
            CONTENT.CREATED_BY = UPPER( :current_user )
          ' || '  OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT.CREATED_BY
    END AS CREATED_BY,
    CONTENT.CREATED_ON,
    CASE
        WHEN
            CONTENT.UPDATED_BY = UPPER( :current_user )
            OR AUTHORIZATION.HAS_ROLE_YN( P_EMAIL => UPPER( :current_user ), P_ROLE => ''ADMINISTRATOR'' ) = ''Y''
        THEN
            CONTENT.UPDATED_BY
    END AS UPDATED_BY,
    CONTENT.UPDATED_ON,
    CREATED_BY_USERS.DISPLAY_NAME AS CREATED_BY_DISPLAY_NAME,
    UPDATED_BY_USERS.DISPLAY_NAME AS UPDATED_BY_DISPLAY_NAME,
    CONTENT.SEARCH_SCORE
FROM
    (
        SELECT 
            *
        FROM 
            CONTENT_NORMALIZED_TABLE(
                P_CONTENT_LIKE_TABLE => TUTORIALS_UNION,
                P_CONTENT_METRICS_MV => TUTORIALS_METRICS_MV,
                P_CONTENT_USER_METRICS_TABLE => TUTORIALS_USER_METRICS,
                P_CONTENT_TYPE => ''TUTORIAL'',
                P_SELF_URI_PREFIX => ''../tutorial' || 's/'',
                P_CURRENT_USER => UPPER( :current_user ),
                P_INCLUDE_USER_METRICS_1_0 => 1,
                P_INCLUDE_SELF_COLUMN_1_0 => 1,
                P_SHORTEN_DESCRIPTION_1_0 => 1,
                P_INCLUDE_CONTENT_COLUMNS_1_0 => 1,
                P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
                P_INCLUDE_UPDATED_BY_COL_1_0 => 1
            )
        UNION ALL
        SELECT
            *
        FROM
            CONTENT_NORMALIZED_TABLE(
                P_CONTENT_LIKE_TABLE => SCRIPTS_UNION,
                P_CONTENT_METRICS_MV => SCRIPTS_METRICS_MV,
                P_CONTENT_USER_METRICS_TABLE => SCRIPTS_USER_METRICS,
                P_CONTENT_TYPE => ''SCRIPT'',
                P_SELF_URI_PREFIX => ''../scripts/'',
                P_CURRENT_USER => UPPER( :current_user ),
                P_INCLUDE_USER_METRICS_1_0 => 1,
                P_INCLUDE_SELF_COLUMN_1_0 => 1,
                P_SHORTEN_DESCRIPTION_1_0 => 1,
                P_INCLUDE_CONTENT_COLUMNS_1_' || '0 => 1,
                P_INCLUDE_SHARE_KEY_COL_1_0 => 1,
                P_INCLUDE_UPDATED_BY_COL_1_0 => 1
            )
    ) CONTENT LEFT JOIN USERS CREATED_BY_USERS ON
        CONTENT.CREATED_BY = CREATED_BY_USERS.EMAIL
    LEFT JOIN USERS UPDATED_BY_USERS ON
        CONTENT.UPDATED_BY = UPDATED_BY_USERS.EMAIL');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    STATEMENTS.CREATED_ON,
    STATEMENTS.CODE_LANGUAGE,
    STATEMENTS.ID,
    STATEMENTS.CREATED_BY,
    STATEMENTS.CONTENT,
    DATABASES.VERSION AS DB_VERSION,
    JSON_QUERY ( STATEMENTS.RESULT, ''$'' RETURNING CLOB ) RESULT
FROM
    STATEMENTS
    JOIN SCHEMAS ON STATEMENTS.SCHEMA_ID = SCHEMAS.ID
    JOIN DATABASES ON SCHEMAS.DATABASE_ID = DATABASES.ID
WHERE 
    UPPER( :current_user ) IS NOT NULL 
    AND (
        :version IS NULL
        OR :version = DATABASES.VERSION
    )
    AND (
        STATEMENTS.CREATED_BY = UPPER( :current_user )
    )
    AND (
        :search_term IS NULL OR ( UPPER( STATEMENTS.CONTENT ) LIKE ''%'' || UPPER( :search_term ) || ''%'' )
    )
ORDER BY STATEMENTS.CREATED_ON DESC');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_STATEMENT_ID NUMBER;

    L_IS_SIGNED BOOLEAN;

    L_READ_ONLY_SCHEMA_ID NUMBER;
BEGIN
    L_IS_SIGNED := L_CURRENT_USER IS NOT NULL;

   IF NOT L_IS_SIGNED THEN
        L_CURRENT_USER := ''ANONYMOUS'';
        L_READ_ONLY_SCHEMA_ID := USER_SCHEMAS.GET_READ_ONLY_SCHEMA( :db_version ).ID;
    END IF;

    INSERT INTO STATEMENTS(
        CONTENT,
        CODE_LANGUAGE,
        CREATED_BY,
        RESULT,
        SCHEMA_ID
    ) VALUES (
        :content,
        :code_language,
        L_CURRENT_USER,
        :result,
        CASE 
            WHEN L_IS_SIGNED THEN user_schemas.GET_USER_SCHEMA( L_CURRENT_USER, :db_version  ).id
            ELSE L_READ_ONLY_SCHEMA_ID
        END
    ) RETURNING ID INTO L_STATEMENT_ID;
    :status_code := 201;
    :forward_location := L_STATEMENT_ID;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_code := ' || '400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/:statement_id',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/:statement_id',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    USER_ROLES AS (
        SELECT
            COLUMN_VALUE AS NAME
        FROM
            AUTHORIZATION.GET_ROLES( UPPER( :current_user ) )
    )
SELECT 
    *
FROM 
    STATEMENTS
WHERE 
    ID = :statement_id 
    AND (
        CREATED_BY = UPPER( :current_user )
        OR ''ADMINISTRATOR'' IN ( SELECT NAME FROM USER_ROLES )
    )');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/:statement_id',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
BEGIN

    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_CURRENT_ROLES THEN
        DECLARE
            L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
        BEGIN
            SELECT
                CASE WHEN COUNT( 1 ) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_RECORD_YN
            FROM
                STATEMENTS
            WHERE
                ID = :statement_id
                AND CREATED_BY = L_CURRENT_USER;

            IF L_IS_OWN_RECORD_YN = ''N'' THEN
                :status_code := 404;
                RETURN;
            END IF;
        END;
    END IF;

    DELETE FROM STATEMENTS WHERE ID = :statement_id;
    :status_code := 204;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_RE' || 'ASON( SQLERRM );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_WORKSHEET_ID VARCHAR2(36);
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
        RETURN;
    END IF;

    INSERT INTO WORKSHEETS(
        NAME,
        CONTENT,
        CODE_LANGUAGE,
        CREATED_BY,
        LAST_OPENED_ON
    ) VALUES (
        :name,
        :content,
        :code_language,
        L_CURRENT_USER,
        CURRENT_TIMESTAMP
    ) RETURNING ID INTO L_WORKSHEET_ID;
    :status_code := 201;
    :forward_location := L_WORKSHEET_ID;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    USER_ROLES AS (
        SELECT
            COLUMN_VALUE AS NAME
        FROM
            AUTHORIZATION.GET_ROLES( UPPER( :current_user ) )
)
SELECT
    ID,
    NAME,
    CONTENT,
    CODE_LANGUAGE,
    UPDATED_ON,
    CREATED_ON,
    CREATED_BY,
    LAST_OPENED_ON
FROM
    WORKSHEETS
WHERE
    (
        CREATED_BY = UPPER( :current_user )
        OR ''ADMINISTRATOR'' IN ( SELECT NAME FROM USER_ROLES )
    )
    AND (
        :search_term IS NULL OR (UPPER(NAME) LIKE ''%'' || UPPER(:search_term) || ''%'')
    )
ORDER BY UPDATED_ON DESC');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
        RETURN;
    END IF;

    UPDATE
        WORKSHEETS
    SET
        LAST_OPENED_ON = NULL
    WHERE
        CREATED_BY = L_CURRENT_USER;

    :status_code := 200;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/:worksheet_id',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/:worksheet_id',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    UNAUTHORIZED EXCEPTION;
    BAD_REQUEST EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        RAISE UNAUTHORIZED;
    END IF;

    IF :action NOT IN ( ''UPDATE'', ''OPEN'' ) THEN
        RAISE BAD_REQUEST;
    END IF;

    IF :action = ''UPDATE'' THEN

        UPDATE
            WORKSHEETS
        SET
            CONTENT = :content,
            UPDATED_ON = CURRENT_TIMESTAMP
        WHERE
            CREATED_BY = L_CURRENT_USER AND ID = :worksheet_id;

        :status_code := 200;
        :forward_location := :worksheet_id;
        RETURN;
    ELSIF :action = ''OPEN'' THEN

        UPDATE
            WORKSHEETS
        SET
            LAST_OPENED_ON = CURRENT_TIMESTAMP
        WHERE
            CREATED_BY = L_CURRENT_USER AND ID = :worksheet_id;
        :status_code := 200;
        :forward_location := :worksheet_id;
        RETURN;
    END IF;

EXCEPTION
    WHEN UNAUTHORIZED THE' || 'N
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/:worksheet_id',
      p_method         => 'GET',
      p_source_type    => 'json/item',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'WITH
    USER_ROLES AS (
        SELECT
            COLUMN_VALUE AS NAME
        FROM
            AUTHORIZATION.GET_ROLES( UPPER( :current_user ) )
)
SELECT
    ID,
    NAME,
    CONTENT,
    UPDATED_ON,
    CREATED_ON,
    CREATED_BY,
    CODE_LANGUAGE,
    LAST_OPENED_ON
FROM
    WORKSHEETS
WHERE 
    (
        ''ADMINISTRATOR'' IN ( SELECT NAME FROM USER_ROLES )
        OR CREATED_BY = UPPER( :current_user ) 
    )
    AND ID = :worksheet_id');

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/:worksheet_id',
      p_method         => 'DELETE',
      p_source_type    => 'plsql/block',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    L_CURRENT_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );
BEGIN

    IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
        :status_code := 401;
        RETURN;
    END IF;

    IF ''ADMINISTRATOR'' NOT MEMBER OF L_CURRENT_ROLES THEN
        DECLARE
            L_IS_OWN_WORKSHEET VARCHAR2(1) := ''N'';
        BEGIN
            SELECT 
                CASE WHEN COUNT(1) > 0 THEN ''Y'' ELSE ''N'' END
            INTO
                L_IS_OWN_WORKSHEET
            FROM
                WORKSHEETS
            WHERE
                CREATED_BY = L_CURRENT_USER;

            IF L_IS_OWN_WORKSHEET = ''N'' THEN
                :status_code := 404;
                RETURN;
            END IF;
        END;
    END IF;

    DELETE FROM WORKSHEETS WHERE ID = :worksheet_id;
    :status_code := 204;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_c' || 'ode := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/batch/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'worksheets/batch/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_WORKSHEETS_LIST_OBJECT JSON_OBJECT_T;
    L_WORKSHEETS_LIST JSON_ARRAY_T;
    L_WORKSHEET JSON_OBJECT_T;
    L_WORKSHEET_NAME VARCHAR2(128);
    L_WORKSHEET_CONTENT CLOB;
    L_WORKSHEET_CODE_LANGUAGE VARCHAR2(128);
    L_WORKSHEETS_COUNT NUMBER;
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    UNAUTHORIZED EXCEPTION;
BEGIN
    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        RAISE UNAUTHORIZED;
    END IF;

    INSERT INTO WORKSHEETS (
        NAME,
        CONTENT,
        CODE_LANGUAGE,
        CREATED_BY
    )
    WITH
        USER_WORKSHEETS AS (
            SELECT
                DISTINCT NAME
            FROM
                WORKSHEETS
            WHERE
                CREATED_BY = L_CURRENT_USER
        ),
        PAYLOAD_WORKSHEETS AS (
            SELECT
                ARRAY_INDEX - 1 AS ARRAY_INDEX,
                NAME,
                CONTENT,
                CODE_LANGUAGE
            FROM
                JSON_TABLE(' || '
                    :body,
                    ''$.worksheet_list[*]'' COLUMNS (
                        ARRAY_INDEX FOR ORDINALITY,
                        NAME VARCHAR PATH ''$.name'',
                        CONTENT PATH ''$.content'', --CLOB doesn''t exist in JSON_TABLE
                        CODE_LANGUAGE PATH ''$.code_language''
                    )
                )
        ),
        PAYLOAD_INDEXES AS (
            SELECT
                PAYLOAD_WORKSHEETS.ARRAY_INDEX AS PAYLOAD_ARRAY_INDEX,
                PAYLOAD_WORKSHEETS.NAME AS PAYLOAD_NAME,
                PAYLOAD_WORKSHEETS.CONTENT AS PAYLOAD_CONTENT,
                PAYLOAD_WORKSHEETS.CODE_LANGUAGE AS PAYLOAD_CODE_LANGUAGE,
                TO_NUMBER( NVL( REGEXP_REPLACE( REGEXP_SUBSTR( NVL( MAX( USER_WORKSHEETS.NAME ), ''(-1)'' ), ''\([-0-9]+\)$'' ), ''[()]'', '''' ), 0 ) ) + 1 AS NAME_INDEX
            FROM
                PAYLOAD_WORKSHEETS LEFT JOIN USER_WORKSHEETS ON
                    INSTR(USER_WORKSHEETS.NAME, PAYLOAD_WORKS' || 'HEETS.NAME) = 1
            GROUP BY
                PAYLOAD_WORKSHEETS.ARRAY_INDEX,
                PAYLOAD_WORKSHEETS.NAME,
                PAYLOAD_WORKSHEETS.CONTENT,
                PAYLOAD_WORKSHEETS.CODE_LANGUAGE
        )
    SELECT
        PAYLOAD_NAME || CASE WHEN NAME_INDEX > 0 THEN ''('' || NAME_INDEX || '')'' END AS NEW_NAME,
        PAYLOAD_CONTENT,
        PAYLOAD_CODE_LANGUAGE,
        L_CURRENT_USER
    FROM
        PAYLOAD_INDEXES;

    :status_code := 201;
EXCEPTION
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/batch/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'statements/batch/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    sql_history_list_object JSON_OBJECT_T;
    sql_history_list JSON_ARRAY_T;
    statement JSON_OBJECT_T;
    statement_timestamp TIMESTAMP;
    statement_text CLOB;
    statement_db_version VARCHAR2(320 BYTE);
    result CLOB;
    L_STATEMENT_ID NUMBER;
BEGIN

    IF NOT AUTHORIZATION.HAS_ROLE( L_CURRENT_USER, ''BASIC'' ) THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
        RETURN;
    END IF;

    sql_history_list_object := JSON_OBJECT_T.parse(:body);
    sql_history_list := sql_history_list_object.get_array(''sql_history_list'');

    FOR ind IN 0..sql_history_list.get_size - 1
    LOOP
        statement := TREAT(sql_history_list.get(ind) as JSON_OBJECT_T);
        result := statement.TO_CLOB;
        statement_text := statement.get_clob(''statementText'');
        statement_timestamp := statement.get_timestamp(''statementTimestamp'');
        statement' || '_db_version := statement.get_string(''db_version'');
        INSERT INTO STATEMENTS(
            CONTENT,
            CREATED_BY,
            SCHEMA_ID,
            RESULT
        ) VALUES (
            statement_text,
            L_CURRENT_USER,
            USER_SCHEMAS.ASSIGN_SCHEMA_TO_USER( L_CURRENT_USER, statement_db_version ).id,
            UTL_RAW.CAST_TO_RAW(result)
        ) RETURNING ID INTO L_STATEMENT_ID;
    END LOOP;
    :status_code := 201;
    :forward_location := L_STATEMENT_ID;
EXCEPTION
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'me/accept-terms',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'me/accept-terms',
      p_method         => 'PUT',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );

    UNAUTHORIZED EXCEPTION;
BEGIN
    IF L_CURRENT_USER IS NULL THEN
        RAISE UNAUTHORIZED;
    END IF;

    UPDATE
        USERS
    SET
        DISCLAIMER_ACCEPTED_ON = SYSTIMESTAMP
    WHERE
        EMAIL = L_CURRENT_USER;

    :status_code := 204;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -- NOTE: Do not surface SQLERRM as that may leak schema details
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/batch/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'scripts/:script_slug/statements/batch/',
      p_method         => 'POST',
      p_source_type    => 'plsql/block',
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'DECLARE
    L_CURRENT_USER VARCHAR2(320 BYTE) := UPPER( :current_user );
    L_ID NUMBER;
    L_IS_MY_CREATED_YN VARCHAR2(1);

    L_ROLES VC2_TABLE_T := AUTHORIZATION.GET_ROLES( L_CURRENT_USER );

    SCRIPT_STATEMENTS_LIST_OBJECT JSON_OBJECT_T;
    SCRIPT_STATEMENTS_LIST JSON_ARRAY_T;
    SCRIPT_STATEMENT JSON_OBJECT_T;
    SCRIPT_STATEMENTS_TITLE VARCHAR2(128);
    SCRIPT_STATEMENTS_CONTENT CLOB;

    BAD_REQUEST EXCEPTION;
    NOT_FOUND EXCEPTION;
    UNAUTHORIZED EXCEPTION;
    FORBIDDEN EXCEPTION;
BEGIN

    IF ''BASIC'' NOT MEMBER OF L_ROLES THEN
        RAISE UNAUTHORIZED;
    END IF;

    BEGIN
        SELECT
            ID,
            CASE WHEN CREATED_BY = L_CURRENT_USER THEN ''Y'' ELSE ''N'' END AS IS_MY_CREATED
        INTO
            L_ID,
            L_IS_MY_CREATED_YN
        FROM
            SCRIPTS
        WHERE
            SLUG = :script_slug;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOT_FOUND;
    END;

    IF
        ''ADMINISTRATOR'' NOT MEMBER OF' || ' L_ROLES
        AND L_IS_MY_CREATED_YN != ''Y''
    THEN
        RAISE FORBIDDEN;
    END IF;

    SCRIPT_STATEMENTS_LIST_OBJECT := JSON_OBJECT_T.parse(:body);
    SCRIPT_STATEMENTS_LIST := SCRIPT_STATEMENTS_LIST_OBJECT.GET_ARRAY(''script_statements_list'');

    FOR IND IN 0..SCRIPT_STATEMENTS_LIST.GET_SIZE - 1
    LOOP
        SCRIPT_STATEMENT := TREAT(SCRIPT_STATEMENTS_LIST.get(IND) AS JSON_OBJECT_T);
        SCRIPT_STATEMENTS_TITLE := SCRIPT_STATEMENT.GET_STRING(''title'');
        SCRIPT_STATEMENTS_CONTENT := SCRIPT_STATEMENT.GET_CLOB(''content'');
        INSERT INTO SCRIPTS_STATEMENTS(
        TITLE,
        CONTENT,
        SEQUENCE,
        SCRIPT_ID,
        CREATED_BY,
        UPDATED_BY
        ) VALUES (
            SCRIPT_STATEMENTS_TITLE,
            SCRIPT_STATEMENTS_CONTENT,
            IND + 1,
            L_ID,
            L_CURRENT_USER,
            L_CURRENT_USER
        );
    END LOOP;

    :status_code := 201;
EXCEPTION
    -- TODO: Log SQLERRM to a logging table
    -' || '- NOTE: Do not output SQLERRM as that can reveal schema information
    WHEN UNAUTHORIZED THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
        :status_code := 401;
    WHEN FORBIDDEN THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Forbidden'' );
        :status_code := 403;
    WHEN NOT_FOUND THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Not Found'' );
        :status_code := 404;
    WHEN OTHERS THEN
        :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad Request'' );
        :status_code := 400;
END;');

  ORDS.DEFINE_TEMPLATE(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'database_versions/',
      p_priority       => 0,
      p_etag_type      => 'HASH',
      p_etag_query     => NULL,
      p_comments       => NULL);

  ORDS.DEFINE_HANDLER(
      p_module_name    => 'com.oracle.livesql.api',
      p_pattern        => 'database_versions/',
      p_method         => 'GET',
      p_source_type    => 'json/collection',
      p_items_per_page => 25,
      p_mimes_allowed  => NULL,
      p_comments       => NULL,
      p_source         => 
'SELECT
    VERSION
FROM
    DATABASES
ORDER BY
        TO_NUMBER(REGEXP_SUBSTR( VERSION, ''\d+'', 1, 1)) DESC NULLS LAST,
        TO_NUMBER(REGEXP_SUBSTR( VERSION, ''\d+'', 1, 2)) DESC NULLS LAST,
        TO_NUMBER(REGEXP_SUBSTR( VERSION, ''\d+'', 1, 3)) DESC NULLS LAST');

COMMIT;

END;
/

-- SECTION- Commented out endpoints

-- BEGIN
--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/',
--       p_method         => 'POST',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_DATABASE_ID NUMBER;
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES(:current_user);
-- BEGIN
--     -- see if the current user has an ''ADMIN'' role
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401; -- Unauthorized
--         :errorReason := ''Unauthorized'';
--         RETURN;
--     END IF;

--     -- INSERT for an admin user
--     INSERT INTO DATABASES (
--         NAME,
--         TYPE,
--         VERSION,
--         REST_SQL_BASE_URL,
--         ADMIN_SCHEMA_NAME,
--         ADMIN_SCHEMA_ALIAS,
--         ADMIN_OAUTH_CLIENT_ID,
--         ADMIN_OAUTH_CLIENT_SECRET,
--         CREATED_BY,
--         UPDATED_BY
--     ) VALUES (
--         :name,
--         :type,
--         :version,
--         :rest_sql_base_url,
--         :admin_schema_name,
--         :admin_schema_alias,
--         :admin_oauth_client_id,
--         :admin_oauth_client_secret,
--         :current_user,  -- :current_user is the user''s ID
--         :current_user
--     ) RETURNING ID INTO L_DATABASE_ID;

--     :status_code := 201; 
--     :forward_locati' || 'on := L_DATABASE_ID; -- URI for the newly created resource

-- EXCEPTION
--     WHEN NO_DATA_FOUND THEN
--         :errorReason := ''Error: Current user not found.'';
--         :status_code := 404; 
--     WHEN OTHERS THEN
--         :errorReason := ''Unexpected error: '' || SQLERRM;
--         :status_code := 400; 
-- END;');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'SELECT
--     DATABASES.*,
--     DATABASES.ID AS "$self"
-- FROM
--     DATABASES
-- WHERE
--     AUTHORIZATION.HAS_ROLE_YN( :current_user, ''ADMINISTRATOR'' ) = ''Y''');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/:database_id',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/:database_id',
--       p_method         => 'GET',
--       p_source_type    => 'json/item',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH USER_ROLES AS (
--     SELECT COLUMN_VALUE AS NAME
--     FROM AUTHORIZATION.GET_ROLES(:current_user)
-- )
-- SELECT
--     DATABASES.*,
--     ''../schemas/?q={"DATABASE_ID": '' || ID || ''}'' AS "$schemas"
-- FROM
--     DATABASES
-- WHERE
--     ID = :database_id
--     AND ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/:database_id',
--       p_method         => 'PUT',
--       p_source_type    => 'plsql/block',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );
-- BEGIN
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     UPDATE DATABASES
--     SET
--         NAME = :name,
--         TYPE = :type,
--         VERSION = :version,
--         REST_SQL_BASE_URL = :rest_sql_base_url,
--         ADMIN_SCHEMA_NAME = :admin_schema_name,
--         ADMIN_SCHEMA_ALIAS = :admin_schema_alias,
--         ADMIN_OAUTH_CLIENT_ID = :admin_oauth_client_id,
--         ADMIN_OAUTH_CLIENT_SECRET = :admin_oauth_client_secret,
--         UPDATED_BY = :current_user,
--         UPDATED_ON = CURRENT_TIMESTAMP
--     WHERE
--         ID = :database_id;

--     :status_code := 200;
--     :forward_location := :database_id;
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
--         :status_code := 400;
-- END;');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'databases/:database_id',
--       p_method         => 'DELETE',
--       p_source_type    => 'plsql/block',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES(:current_user);
-- BEGIN
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         :errorReason := ''Unauthorized'';
--         RETURN;
--     END IF;

--     DELETE FROM DATABASES WHERE ID = :database_id;
--     :status_code := 204; 
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := ''Unexpected error: '' || SQLERRM;
--         :status_code := 400; -- bad Request
-- END;');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/',
--       p_method         => 'POST',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- '-- TODO: call the deploy_schema function,
-- -- and later save the schema into the database
-- /*
-- DECLARE
--     L_SCHEMAS_ID SCHEMAS.ID%TYPE;

--     L_SCHEMA_NAME SCHEMAS.NAME%TYPE := :name;
--     L_SCHEMA_ALIAS SCHEMAS.ALIAS%TYPE;

--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );

--     INVALID_SCHEMA_NAME EXCEPTION;
-- BEGIN

--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     -- Make sure the schema name starts with a letter and max lenght 30 characters
--     IF NOT REGEXP_LIKE( ''^[A-Z0-9_]{1,14}$'', L_SCHEMA_NAME ) THEN
--         RAISE INVALID_SCHEMA_NAME;
--     END IF;

--     L_SCHEMA_NAME := ''LIVE_SQL_SCHEMA_'' || TRIM( BOTH ''_'' FROM L_SCHEMA_NAME );
--     L_SCHEMA_ALIAS := LOWER( L_SCHEMA_NAME );

--     INSERT INTO SCHEMAS(
--         NAME,
--         ALIAS,
--         STATUS,
--         DATABASE_ID,
--         CREATED_BY,
--         UPDATED_BY
--     ) VALUES (
--         L_SCHEMA_NAME,
--         L_SCHEMA_ALIAS,
--         -- NOTE: Schemas are created i' || 'n BULK via a job
--         ''NEW'',
--         :database_id,
--         :current_user,
--         :current_user
--     ) RETURNING ID INTO L_SCHEMAS_ID;

--     -- TODO: Create PROCESS_SCHEMAS job
--     -- DBMS_SCHEDULER.RUN_JOB( ''PROCESS_SCHEMAS'' );

--     :status_code := 201;
--     :forward_location := L_SCHEMAS_ID;
-- EXCEPTION
--     WHEN INVALID_SCHEMA_NAME THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON(
--             ''The provided schema name is invalid. Please provide a schema name containing at least 1 and up to 14 ASCII uppercase alphabetic characters, numbers or underscores''
--         );
--         :status_code := 400;
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( SQLERRM );
--         :status_code := 400;
-- END;
-- */

-- DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );
-- BEGIN
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     :status_code := 201;
-- END;');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT 
--             COLUMN_VALUE AS NAME
--         FROM 
--             AUTHORIZATION.GET_ROLES( :current_user )
--     )
-- SELECT
--     SCHEMAS.*,
--     ID AS "$self"
-- FROM
--     SCHEMAS
-- WHERE
--     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/:schema_id',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/:schema_id',
--       p_method         => 'GET',
--       p_source_type    => 'json/item',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH USER_ROLES AS (
--     SELECT
--         COLUMN_VALUE AS NAME
--     FROM
--         AUTHORIZATION.GET_ROLES(:current_user)
-- )
-- SELECT
--     SCHEMAS.*,
--     ''../databases/'' || DATABASE_ID AS "$database"
-- FROM
--     SCHEMAS
-- WHERE
--     ID = :schema_id
--     AND ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/batch/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'schemas/batch/',
--       p_method         => 'POST',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- '-- Call the DEPLOY_SCHEMAS() function from the SCHEMA_MANAGEMENT package,
-- -- and later, save the new schemas into the database
-- /*
-- DECLARE
--     L_INSERTED_ROWS_COUNT NUMBER;
--     L_CURRENT_ERROR_MESSAGE VARCHAR2(32767);
--     L_CURRENT_LINK_HREF VARCHAR2(32767);
--     L_RESPONSE CLOB;

--     L_BATCH_SIZE INTEGER := :batch_size;
--     L_DATABASE_ID SCHEMAS.DATABASE_ID%TYPE := :database_id;
--     L_DOES_DATABASE_EXISTS VARCHAR(1) := ''N'';
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user ); -- Checking the role

--     TYPE T_INSERTED_SCHEMA IS RECORD(
--         ID SCHEMAS.ID%TYPE,
--         NAME SCHEMAS.NAME%TYPE
--     );
--     TYPE T_INSERTED_SCHEMAS IS TABLE OF T_INSERTED_SCHEMA;

--     L_SCHEMAS_NAMES T_ORDS_VCHAR_TAB;
--     L_INSERTED_SCHEMAS T_INSERTED_SCHEMAS;

--     C_INVALID_BATCH_SIZE_MESSAGE CONSTANT VARCHAR2(128) := ''Invalid batch size. Please use a batch size between 1 and 50'';
--     C_INVALID_DATABASE_ID_MESSAGE CONSTANT VARCHAR2(128) := ''Invalid database ID'';

--     INVALID_BATCH_SIZE E' || 'XCEPTION;
--     INVALID_DATABASE_ID EXCEPTION;
--     DML_ERRORS EXCEPTION;
--     PRAGMA EXCEPTION_INIT( DML_ERRORS, -24381 );

--     PROCEDURE APPEND_SUCCESS_KEYS_TO_RESPONSE IS
--     BEGIN
--         DBMS_LOB.APPEND( L_RESPONSE, ''"items":['' );
--             FOR I IN L_INSERTED_SCHEMAS.FIRST .. L_INSERTED_SCHEMAS.LAST LOOP
--                 IF I > 1 THEN
--                     DBMS_LOB.APPEND( L_RESPONSE, '','' );
--                 END IF;
--                 DBMS_LOB.APPEND( L_RESPONSE, ''{'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"name":"'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ORDS_UTIL.STRING_TO_JSON( L_INSERTED_SCHEMAS( I ).NAME ) );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''",'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"id":"'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, TO_CHAR( L_INSERTED_SCHEMAS( I ).ID ) );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''",'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"links":['' );
--                         DBM' || 'S_LOB.APPEND( L_RESPONSE, ''{'' );
--                             DBMS_LOB.APPEND( L_RESPONSE, ''"rel":"self",'' );
--                             DBMS_LOB.APPEND( L_RESPONSE, ''"href":"'' );
--                             L_CURRENT_LINK_HREF := ''../'' || L_INSERTED_SCHEMAS( I ).ID;
--                             DBMS_LOB.APPEND( L_RESPONSE, ORDS_UTIL.STRING_TO_JSON( L_CURRENT_LINK_HREF ) );
--                             L_CURRENT_LINK_HREF := NULL;
--                             DBMS_LOB.APPEND( L_RESPONSE, ''"'' );
--                         DBMS_LOB.APPEND( L_RESPONSE, ''}'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, '']'' );
--                 DBMS_LOB.APPEND( L_RESPONSE, ''}'' );
--             END LOOP;
--         DBMS_LOB.APPEND( L_RESPONSE, ''],'' );
--         DBMS_LOB.APPEND( L_RESPONSE, ''"count":'' );
--         DBMS_LOB.APPEND( L_RESPONSE, TO_CHAR( L_INSERTED_ROWS_COUNT ) );
--     END;
--     PROCEDURE APPEND_ERROR_KEYS_TO_RESPONSE IS
--     BEGIN
--         DBMS_LOB.APPEND( L_RESPONSE, ''"errors":['' );
--             FOR I IN 1 ..' || ' SQL%BULK_EXCEPTIONS.COUNT LOOP
--                 IF I > 1 THEN
--                     DBMS_LOB.APPEND( L_RESPONSE, '','' );
--                 END IF;
--                 DBMS_LOB.APPEND( L_RESPONSE, ''{'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"name":"'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ORDS_UTIL.STRING_TO_JSON( L_SCHEMAS_NAMES( SQL%BULK_EXCEPTIONS( I ).ERROR_INDEX ) ) );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''",'' );
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"sqlerrm":"'' );
--                     L_CURRENT_ERROR_MESSAGE := SQLERRM( -1 * SQL%BULK_EXCEPTIONS( I ).ERROR_CODE );
--                     DBMS_LOB.APPEND( L_RESPONSE, ORDS_UTIL.STRING_TO_JSON( L_CURRENT_ERROR_MESSAGE ) );
--                     L_CURRENT_ERROR_MESSAGE := NULL;
--                     DBMS_LOB.APPEND( L_RESPONSE, ''"'' );
--                 DBMS_LOB.APPEND( L_RESPONSE, ''}'' );
--             END LOOP;
--         DBMS_LOB.APPEND( L_RESPONSE, ''],'' );
--         DBMS_LOB.APPEND( L_RESPONSE, ''"sqlerrm":"'' )' || ';
--         L_CURRENT_ERROR_MESSAGE := SQLERRM;
--         DBMS_LOB.APPEND( L_RESPONSE, ORDS_UTIL.STRING_TO_JSON( L_CURRENT_ERROR_MESSAGE ) );
--         L_CURRENT_ERROR_MESSAGE := NULL;
--         DBMS_LOB.APPEND( L_RESPONSE, ''"'' );
--     END;
-- BEGIN
--     -- Check whether the user is an admin or not
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     IF L_BATCH_SIZE <= 0 OR L_BATCH_SIZE > 50 THEN
--         RAISE INVALID_BATCH_SIZE;
--     END IF;

--     SELECT
--         CASE WHEN COUNT( 1 ) > 0 THEN ''Y'' ELSE ''N'' END AS DOES_DATABASE_EXISTS
--     INTO
--         L_DOES_DATABASE_EXISTS
--     FROM
--         (
--             SELECT ID FROM DATABASES WHERE ID = L_DATABASE_ID
--         );
--     IF L_DOES_DATABASE_EXISTS = ''N'' THEN
--         RAISE INVALID_DATABASE_ID;
--     END IF;

--     WITH GENERATED_SCHEMA_NAMES AS (
--         SELECT
--             ''LIVE_SQL_SCHEMA_'' || DBMS_RANDOM.STRING( ''X'', 14 ) AS NAME
--         FROM
--             DUAL
--         CONNECT BY
--             LEVEL <= L_' || 'BATCH_SIZE * 10
--     )
--     SELECT
--         NAME
--     BULK COLLECT INTO
--         L_SCHEMAS_NAMES
--     FROM
--         GENERATED_SCHEMA_NAMES
--     WHERE
--         -- TODO: Check performance against JOIN
--         NAME NOT IN ( SELECT NAME FROM SCHEMAS WHERE NAME = GENERATED_SCHEMA_NAMES.NAME )
--         AND ROWNUM <= L_BATCH_SIZE;

--     FORALL I IN 1 .. L_SCHEMAS_NAMES.COUNT SAVE EXCEPTIONS
--         INSERT INTO SCHEMAS(
--             NAME,
--             ALIAS,
--             STATUS,
--             DATABASE_ID,
--             CREATED_BY,
--             UPDATED_BY
--         ) VALUES (
--             L_SCHEMAS_NAMES( I ),
--             LOWER( L_SCHEMAS_NAMES( I ) ),
--             -- NOTE: Schemas are created in BULK via a job
--             ''NEW'',
--             :database_id,
--             :current_user,
--             :current_user
--         ) RETURNING ID, NAME BULK COLLECT INTO L_INSERTED_SCHEMAS;

--     -- TODO: Create PROCESS_SCHEMAS job
--     -- DBMS_SCHEDULER.RUN_JOB( ''PROCESS_SCHEMAS'' );

--     L_INSERTED_ROWS_COUNT := SQL%ROWCOUNT;

--     DBMS' || '_LOB.CREATETEMPORARY( L_RESPONSE, TRUE, DBMS_LOB.CALL );
--     DBMS_LOB.APPEND( L_RESPONSE, ''{'' );
--     APPEND_SUCCESS_KEYS_TO_RESPONSE();
--     DBMS_LOB.APPEND( L_RESPONSE, ''}'' );

--     :status_code := 201;
--     OWA_UTIL.MIME_HEADER(
--         CCONTENT_TYPE => ''application/json'',
--         BCLOSE_HEADER => TRUE
--     );
--     ORDS_UTIL.HTP_PRINT_CLOB( L_RESPONSE );
--     DBMS_LOB.FREETEMPORARY( L_RESPONSE );
-- EXCEPTION
--     WHEN INVALID_BATCH_SIZE THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( C_INVALID_BATCH_SIZE_MESSAGE);
--         :status_code := 400;
--     WHEN INVALID_DATABASE_ID THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( C_INVALID_DATABASE_ID_MESSAGE );
--         :status_code := 400;
--     WHEN DML_ERRORS THEN
--         BEGIN
--             L_INSERTED_ROWS_COUNT := SQL%ROWCOUNT;

--             DBMS_LOB.CREATETEMPORARY( L_RESPONSE, TRUE, DBMS_LOB.CALL );
--             DBMS_LOB.APPEND( L_RESPONSE, ''{'' );
--                 APPEND_SUCCESS_KEYS_TO_RESPONSE();
--                 DBMS_LOB.A' || 'PPEND( L_RESPONSE, '','' );
--                 APPEND_ERROR_KEYS_TO_RESPONSE();
--             DBMS_LOB.APPEND( L_RESPONSE, ''}'' );

--             :status_code := CASE WHEN L_INSERTED_ROWS_COUNT > 0 THEN 201 ELSE 500 END;
--             OWA_UTIL.MIME_HEADER(
--                 CCONTENT_TYPE => ''application/json'',
--                 BCLOSE_HEADER => TRUE
--             );
--             ORDS_UTIL.HTP_PRINT_CLOB( L_RESPONSE );
--             DBMS_LOB.FREETEMPORARY( L_RESPONSE );
--         EXCEPTION
--             WHEN OTHERS THEN
--                 :errorReason := UTILITIES.STRING_TO_ERROR_REASON( SQLERRM );
--                 :status_code := 400;
--         END;
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( SQLERRM );
--         :status_code := 400;
-- END;
-- */');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'users/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'users/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT 
--             COLUMN_VALUE AS NAME
--         FROM 
--             AUTHORIZATION.GET_ROLES( :current_user )
--     )
-- SELECT
--     -- Remember that REST SQL returns all the columns, but not when you use CURL
--     USERS.*,
--     USERS.ID as "$self"
-- FROM
--     USERS
-- WHERE
--     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'users/:user_id',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'users/:user_id',
--       p_method         => 'PUT',
--       p_source_type    => 'plsql/block',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );
-- BEGIN
--     IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     -- TODO: If I''m the user I could change only my display_name    
--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         DECLARE
--             L_IS_OWN_USER VARCHAR2(1) := ''N'';
--         BEGIN
--             SELECT
--                 CASE WHEN COUNT( 1 ) > 0 THEN ''Y'' ELSE ''N'' END
--             INTO
--                 L_IS_OWN_USER
--             FROM
--                 USERS
--             WHERE
--                 ID = :user_id
--                 AND EMAIL = :current_user;

--             IF L_IS_OWN_USER = ''N'' THEN
--                 :status_code := 404;
--                 RETURN;
--             ELSE
--                 UPDATE
--                     USERS
--                 SET
--                     DISPLAY_NAME = NVL(:display_name, DISPLAY_NAME)
--                 WHERE
--                     ID = :user_id;

--                 :status_code := 204;' || '
--                 :forward_location := :user_id;

--                 RETURN;
--             END IF;
--         END;
--     END IF;

--     -- Admin can modify anything
--     UPDATE
--         USERS
--     SET
--         EMAIL = NVL(:email, EMAIL),
--         DISPLAY_NAME = NVL(:display_name, DISPLAY_NAME),
--         CREATED_BY = NVL(:created_by, CREATED_BY),
--         UPDATED_BY = :current_user,
--         UPDATED_ON = CURRENT_TIMESTAMP,
--         ROLE_ID = NVL(:role_id, ROLE_ID)
--     WHERE
--         ID = :user_id;

--     :status_code := 204;
--     :forward_location := :user_id;
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
--         :status_code := 400;
-- END;');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'users/:user_id',
--       p_method         => 'GET',
--       p_source_type    => 'json/item',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT
--             COLUMN_VALUE AS NAME
--         FROM
--             AUTHORIZATION.GET_ROLES( :current_user )
--     )
-- SELECT
--     U.ID,
--     U.EMAIL,
--     U.DISPLAY_NAME,
--     U.DISCLAIMER_ACCEPTED_ON,
--     U.CREATED_BY,
--     U.CREATED_ON,
--     U.UPDATED_BY,
--     U.UPDATED_ON,
--     U.ID || ''/statements/'' AS "$statements"
-- FROM
--     USERS U
-- WHERE
--     -- admins to get any user''s info
--     -- TODO: use authorization package to get the user roles and then, check
--     -- if the user is admin or not
--     ( 
--         ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )

--         -- non-admins (publishers and basic users) only get their own info 
--         OR U.EMAIL = :current_user
--     ) 
--     AND U.ID = :user_id');

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 24,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT
--             COLUMN_VALUE AS NAME
--         FROM
--             AUTHORIZATION.GET_ROLES( :CURRENT_USER )
--     ),
--     USER_DISPLAY_NAMES AS (
--         SELECT DISPLAY_NAME, EMAIL FROM USERS
--     )
-- SELECT
--     -- TODO: rename SCRIPT_ID column name to ID
--     SCRIPTS.SCRIPT_ID,
--     TITLE,
--     DESCRIPTION,
--     PUBLISHED,
--     FEATURED,
--     SETUP_DESCRIPTION,
--     SETUP_CODE,
--     TAGS,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             SHARE_KEY
--     END SHARE_KEY,
--     MIN_DB_VERSION,
--     NVL( SCRIPTS_METRICS_MV.LIKES, 0 ) AS LIKES,
--     NVL( SCRIPTS_METRICS_MV.FAVORITES, 0 ) AS FAVORITES,
--     NVL( SCRIPTS_METRICS_MV.EXECUTIONS, 0 ) AS EXECUTIONS,
--     CREATED_ON,
--     CREATED_BY,
--     CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
--     UPDATED_ON,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USE' || 'R
--         THEN
--             UPDATED_BY
--     END UPDATED_BY,
--     UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME
-- FROM
--     SCRIPTS LEFT JOIN USER_DISPLAY_NAMES CREATED_BY_DISPLAY_NAMES ON
--         SCRIPTS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN USER_DISPLAY_NAMES UPDATED_BY_DISPLAY_NAMES ON
--         SCRIPTS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN SCRIPTS_METRICS_MV ON
--         SCRIPTS.SCRIPT_ID = SCRIPTS_METRICS_MV.SCRIPT_ID
-- WHERE
--     (
--         (
--             (
--                 :CURRENT_USER IS NOT NULL
--                 AND (
--                     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)
--                     OR (
--                         PUBLISHED = ''Y''
--                         OR CREATED_BY = :CURRENT_USER
--                     )
--                 )
--             )
--             OR PUBLISHED = ''Y''
--         )
--         AND (
--             :SHOW_LIKED_ONLY = ''FALSE''
--             OR :SHOW_LIKED_ONLY IS NULL
--             OR (
--                 :SHOW_LIKED_ONLY = ''TRUE''
--  ' || '               AND EXISTS (
--                     SELECT 1
--                     FROM SCRIPTS_METRICS
--                     WHERE
--                         SCRIPTS_METRICS.SCRIPT_ID = SCRIPTS.SCRIPT_ID
--                         AND SCRIPTS_METRICS.ACTION = ''LIKE''
--                         AND SCRIPTS_METRICS.USER_EMAIL = :CURRENT_USER
--                 )
--             )
--         )
--          AND (
--             :MY_CONTENT = ''FALSE''
--             OR :MY_CONTENT IS NULL
--             OR CREATED_BY = :CURRENT_USER
--         )
--         AND (
--             (
--                 :VISIBILITY = ''PRIVATE''
--                 AND PUBLISHED = ''N''
--                 AND (
--                     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)
--                     OR CREATED_BY = :CURRENT_USER
--                 )
--             )
--             OR (
--                 :VISIBILITY = ''SHAREABLE''
--                 AND PUBLISHED = ''Y''
--             )
--             OR :VISIBILITY =''ALL''
--             OR :VISIBILITY IS NULL

--         )

--          AND (:RECENT_SCRIPTS IS NULL ' || 'OR SCRIPTS.SCRIPT_ID IN (
--     SELECT TO_NUMBER(REGEXP_SUBSTR(:RECENT_SCRIPTS, ''[^,]+'', 1, LEVEL))
--     FROM DUAL
--     CONNECT BY LEVEL <= REGEXP_COUNT(:RECENT_SCRIPTS, '','') + 1
-- ))
--     )');
--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/search/:search_term',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/search/:search_term',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT
--             COLUMN_VALUE AS NAME
--         FROM
--             AUTHORIZATION.GET_ROLES( :CURRENT_USER )
--     ),
--     USER_DISPLAY_NAMES AS (
--         SELECT DISPLAY_NAME, EMAIL FROM USERS
--     )
-- SELECT
--     ID,
--     TITLE,
--     DESCRIPTION,
--     PUBLISHED,
--     FEATURED,
--     SETUP_DESCRIPTION,
--     SETUP_CODE,
--     TAGS,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             SHARE_KEY
--     END SHARE_KEY,
--     MIN_DB_VERSION,
--     NVL( TUTORIALS_METRICS_MV.LIKES, 0 ) AS LIKES,
--     NVL( TUTORIALS_METRICS_MV.FAVORITES, 0 ) AS FAVORITES,
--     NVL( TUTORIALS_METRICS_MV.EXECUTIONS, 0 ) AS EXECUTIONS,
--     CREATED_ON,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             CREATED_BY
--     END CREATED_BY,
--     CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME CREATED_BY_DISPLAY_NAME,
--     UPDATED_ON,
--     CASE
--       ' || '  WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             UPDATED_BY
--     END UPDATED_BY,
--     UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME
-- FROM
--     TUTORIALS LEFT JOIN USER_DISPLAY_NAMES CREATED_BY_DISPLAY_NAMES ON
--         TUTORIALS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN USER_DISPLAY_NAMES UPDATED_BY_DISPLAY_NAMES ON
--         TUTORIALS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN TUTORIALS_METRICS_MV ON
--         TUTORIALS.ID = TUTORIALS_METRICS_MV.TUTORIAL_ID
-- WHERE
--     (
--         (
--             (
--                 :CURRENT_USER IS NOT NULL
--                 AND (
--                     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)
--                     OR (
--                         PUBLISHED = ''Y''
--                         OR CREATED_BY = :CURRENT_USER
--                     )
--                 )
--             )
--             OR PUBLISHED = ''Y''
--         )
--         AND (
--             :SHOW_LIKED_ONLY =' || ' ''FALSE''
--             OR :SHOW_LIKED_ONLY IS NULL
--             OR (
--                 :SHOW_LIKED_ONLY = ''TRUE''
--                 AND EXISTS (
--                     SELECT 1
--                     FROM TUTORIALS_METRICS
--                     WHERE
--                         TUTORIALS_METRICS.TUTORIAL_ID = TUTORIALS.ID
--                         AND TUTORIALS_METRICS.ACTION = ''LIKE''
--                         AND TUTORIALS_METRICS.USER_EMAIL = :CURRENT_USER
--                 )
--             )
--         )
--         AND (
--             :MY_CONTENT = ''FALSE''
--             OR :MY_CONTENT IS NULL
--             OR CREATED_BY = :CURRENT_USER
--         )
--         AND (
--             :search_term IS NULL 
--             OR (
--                 UPPER(TITLE) LIKE ''%'' || UPPER(:search_term) || ''%'' 
--                 OR UPPER(DESCRIPTION) LIKE ''%'' || UPPER(:search_term) || ''%''
--             )
--         )
--     )');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/search/:search_term',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/search/:search_term',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT
--             COLUMN_VALUE AS NAME
--         FROM
--             AUTHORIZATION.GET_ROLES( :CURRENT_USER )
--     ),
--     USER_DISPLAY_NAMES AS (
--         SELECT DISPLAY_NAME, EMAIL FROM USERS
--     )
-- SELECT
--     -- TODO: rename SCRIPT_ID column name to ID
--     SCRIPTS.SCRIPT_ID,
--     TITLE,
--     DESCRIPTION,
--     PUBLISHED,
--     FEATURED,
--     SETUP_DESCRIPTION,
--     SETUP_CODE,
--     TAGS,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             SHARE_KEY
--     END SHARE_KEY,
--     MIN_DB_VERSION,
--     NVL( SCRIPTS_METRICS_MV.LIKES, 0 ) AS LIKES,
--     NVL( SCRIPTS_METRICS_MV.FAVORITES, 0 ) AS FAVORITES,
--     NVL( SCRIPTS_METRICS_MV.EXECUTIONS, 0 ) AS EXECUTIONS,
--     CREATED_ON,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             CREATED_BY
--     END CREATED_BY,
--     CREATED_BY_DISPLAY_NAMES.DISPLAY_NAME' || ' CREATED_BY_DISPLAY_NAME,
--     UPDATED_ON,
--     CASE
--         WHEN
--             ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--             OR CREATED_BY = :CURRENT_USER
--         THEN
--             UPDATED_BY
--     END UPDATED_BY,
--     UPDATED_BY_DISPLAY_NAMES.DISPLAY_NAME UPDATED_BY_DISPLAY_NAME
-- FROM
--     SCRIPTS LEFT JOIN USER_DISPLAY_NAMES CREATED_BY_DISPLAY_NAMES ON
--         SCRIPTS.CREATED_BY = CREATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN USER_DISPLAY_NAMES UPDATED_BY_DISPLAY_NAMES ON
--         SCRIPTS.CREATED_BY = UPDATED_BY_DISPLAY_NAMES.EMAIL
--     LEFT JOIN SCRIPTS_METRICS_MV ON
--         SCRIPTS.SCRIPT_ID = SCRIPTS_METRICS_MV.SCRIPT_ID
-- WHERE
--     (
--         (
--             (
--                 :CURRENT_USER IS NOT NULL
--                 AND (
--                     ''ADMIN'' IN (SELECT NAME FROM USER_ROLES)
--                     OR (
--                         PUBLISHED = ''Y''
--                         OR CREATED_BY = :CURRENT_USER
--                     )
--                 )
--             )
--             OR PUBLISHED = ''Y''
--     ' || '    )
--         AND (
--             :SHOW_LIKED_ONLY = ''FALSE''
--             OR :SHOW_LIKED_ONLY IS NULL
--             OR (
--                 :SHOW_LIKED_ONLY = ''TRUE''
--                 AND EXISTS (
--                     SELECT 1
--                     FROM SCRIPTS_METRICS
--                     WHERE
--                         SCRIPTS_METRICS.SCRIPT_ID = SCRIPTS.SCRIPT_ID
--                         AND SCRIPTS_METRICS.ACTION = ''LIKE''
--                         AND SCRIPTS_METRICS.USER_EMAIL = :CURRENT_USER
--                 )
--             )
--         )
--         AND (
--             :MY_CONTENT = ''FALSE''
--             OR :MY_CONTENT IS NULL
--             OR CREATED_BY = :CURRENT_USER
--         )
--         AND (
--             :search_term IS NULL 
--             OR (
--                 UPPER(TITLE) LIKE ''%'' || UPPER(:search_term) || ''%'' 
--                 OR UPPER(DESCRIPTION) LIKE ''%'' || UPPER(:search_term) || ''%''
--             )
--         )
--     )');
--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'worksheets/recent/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'worksheets/recent/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'WITH
--     USER_ROLES AS (
--         SELECT 
--             COLUMN_VALUE AS NAME
--         FROM
--             AUTHORIZATION.GET_ROLES( :current_user )
-- )
-- SELECT
--     ID,
--     NAME,
--     CONTENT,
--     UPDATED_ON,
--     CREATED_ON,
--     OPENED_ON,
--     CREATED_BY,
--     RECENTLY_OPENED
-- FROM
--     LIVE_SQL.WORKSHEETS
-- WHERE 
--     (
--         CREATED_BY = :current_user 
--         OR ''ADMIN'' IN ( SELECT NAME FROM USER_ROLES )
--     )
--     AND RECENTLY_OPENED = ''Y''
-- ORDER BY OPENED_ON DESC');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'worksheets/:worksheet_id/recent/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'worksheets/:worksheet_id/recent/',
--       p_method         => 'PUT',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'BEGIN
--     IF NOT AUTHORIZATION.HASS_ROLE( :current_user, ''BASIC'' ) THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Unauthorized'' );
--         :status_code := 401;
--         RETURN;
--     END IF;

--     UPDATE
--         WORKSHEETS
--     SET
--         OPENED_ON = CURRENT_TIMESTAMP,
--         RECENTLY_OPENED = ''Y''
--     WHERE
--         CREATED_BY = :current_user AND ID = :worksheet_id;

--     :status_code := 200;
--     :forward_location := :worksheet_id;
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
--         :status_code := 400;
-- END;');
--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/liked/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/liked/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'SELECT * FROM TUTORIALS_METRICS WHERE USER_EMAIL = :current_user AND ACTION = ''LIKE''');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/liked/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/liked/',
--       p_method         => 'GET',
--       p_source_type    => 'json/collection',
--       p_items_per_page => 25,
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'SELECT * FROM SCRIPTS_METRICS WHERE USER_EMAIL = :current_user AND ACTION = ''LIKE''');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/:tutorial_id/share_key/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'tutorials/:tutorial_id/share_key/',
--       p_method         => 'PUT',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );
--     generated_key VARCHAR2(10);
-- BEGIN
--     -- if the role is not BASIC, then we know it''s an anonymous user
--     IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN

--         -- Since we know the user is not admin, we check whether it''s their own tutorial or not
--         DECLARE
--             L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
--         BEGIN
--             SELECT
--                 CASE WHEN COUNT( 1 ) > 0 THEN ''Y'' ELSE ''N'' END
--             INTO
--                 L_IS_OWN_RECORD_YN
--             FROM
--                 TUTORIALS
--             WHERE
--                 ID = :tutorial_id
--                 AND CREATED_BY = :current_user;

--             IF L_IS_OWN_RECORD_YN = ''N'' THEN
--                 -- NOTE: Returning 404 instead of 401 for security/privacy reasons
--                 :status_code := 404;
--                 RETURN;
--         ' || '    END IF;
--         END;
--     END IF;

--     generated_key :=
--         SUBSTR(
--             TRANSLATE(
--                 DBMS_RANDOM.STRING(''A'', 100),
--                 ''ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'',
--                 ''ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789''
--             ),
--             1,
--             10
--         );

--     UPDATE
--         TUTORIALS
--     SET
--         SHARE_KEY = generated_key
--     WHERE
--         ID = :tutorial_id;

--     :status_code := 200;
--     -- :forward_location := :tutorial_id;
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
--         :status_code := 400;
-- END;');

--   ORDS.DEFINE_TEMPLATE(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/:script_id/share_key/',
--       p_priority       => 0,
--       p_etag_type      => 'HASH',
--       p_etag_query     => NULL,
--       p_comments       => NULL);

--   ORDS.DEFINE_HANDLER(
--       p_module_name    => 'com.oracle.livesql.api',
--       p_pattern        => 'scripts/:script_id/share_key/',
--       p_method         => 'PUT',
--       p_source_type    => 'plsql/block',
--       p_mimes_allowed  => NULL,
--       p_comments       => NULL,
--       p_source         => 
-- 'DECLARE
--     L_CURRENT_ROLES VC_TABLE := AUTHORIZATION.GET_ROLES( :current_user );
--     generated_key VARCHAR2(10);
-- BEGIN
--     -- if the role is not BASIC, then we know it''s an anonymous user
--     IF ''BASIC'' NOT MEMBER OF L_CURRENT_ROLES THEN
--         :status_code := 401;
--         RETURN;
--     END IF;

--     IF ''ADMIN'' NOT MEMBER OF L_CURRENT_ROLES THEN

--         -- Since we know the user is not admin, we check whether it''s their own script or not
--         DECLARE
--             L_IS_OWN_RECORD_YN VARCHAR2(1) := ''N'';
--         BEGIN
--             SELECT
--                 CASE WHEN COUNT( 1 ) > 0 THEN ''Y'' ELSE ''N'' END
--             INTO
--                 L_IS_OWN_RECORD_YN
--             FROM
--                 SCRIPTS
--             WHERE
--                 SCRIPT_ID = :script_id
--                 AND CREATED_BY = :current_user;

--             IF L_IS_OWN_RECORD_YN = ''N'' THEN
--                 -- NOTE: Returning 404 instead of 401 for security/privacy reasons
--                 :status_code := 404;
--                 RETURN;
--        ' || '     END IF;
--         END;
--     END IF;

--     -- generated_key :=
--     --     SUBSTR(
--     --         TRANSLATE(
--     --             DBMS_RANDOM.STRING(''A'', 100),
--     --             ''ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'',
--     --             ''ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789''
--     --         ),
--     --         1,
--     --         10
--     --     );

--     generated_key :=
--         SUBSTR(
--             REPLACE(
--                 DBMS_RANDOM.STRING(''A'', 100),
--                 '' '',
--                 ''0123456789''
--             ),
--             1,
--             10
--         );

--     UPDATE
--         SCRIPTS
--     SET
--         SHARE_KEY = generated_key
--     WHERE
--         SCRIPT_ID = :script_id;

--     :status_code := 200;
--     -- :forward_location := :script_id;
-- EXCEPTION
--     WHEN OTHERS THEN
--         :errorReason := UTILITIES.STRING_TO_ERROR_REASON( ''Bad request'' );
--         :status_code := 400;
-- END;');
-- COMMIT
-- END;
-- /

-- !SECTION- Commented out endpoints
