-- IMPORTANT: This script will delete all content from TUTORIALS,
--            TUTORIALS_STEPS, SCRIPTS, SCRIPTS_STATEMENTS, USERS, and
--            CONTENT_CATEGORIES

-- NOTE: This script assumes the tables ORACLE_SQL_TUTORIALS,
--       ORACLE_SQL_TUT_MODULES, ORACLE_SQL_PUBLISHED_CONTENT, ORACLE_SQL_AREAS,
--       ORACLE_SQL_SAVED_SESSIONS, ORACLE_SQL_SAVED_STATEMENTS, and
--       ORACLE_SQL_ADMIN_USERS are available in the system

SET DEFINE '^'
SET ESCAPE OFF
SET ESCAPE '\'
SET VERIFY OFF
SET ECHO OFF

PROMPT INFO: Migrating Live SQL METADATA Legacy Data...

WHENEVER SQLERROR CONTINUE
SET TERMOUT OFF

DELETE FROM TUTORIALS;
DELETE FROM TUTORIALS_STEPS;
DELETE FROM SCRIPTS;
DELETE FROM SCRIPTS_STATEMENTS;
DELETE FROM USERS;
DELETE FROM CONTENT_CATEGORIES;

SET TERMOUT ON
WHENEVER SQLERROR EXIT 1

SET SERVEROUTPUT ON
DECLARE
    L_RESULT NUMBER;

    PREREQUISITES_NOT_MET EXCEPTION;
BEGIN
    SELECT
        1
    INTO
        L_RESULT
    FROM
        DUAL
    WHERE
        -- NOTE: Check if we're on an actual PDB
        SYS_CONTEXT( 'USERENV', 'CON_NAME' ) NOT IN ( 'CDB$ROOT', 'PDB$SEED' );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE( 'ERROR: This script must be executed in a PDB' );
        RAISE PREREQUISITES_NOT_MET;
END;
/
SET SERVEROUTPUT OFF

INSERT INTO
    USERS (
        ID,
        EMAIL,
        DISPLAY_NAME,
        ROLE_ID,
        DISCLAIMER_ACCEPTED_ON,
        IS_BLOCKED,
        CREATED_ON,
        UPDATED_ON
    )
WITH
    ADMIN_USERS AS (
        SELECT
            NULL AS ID,
            UPPER( ORACLE_SQL_ADMIN_USERS.USERNAME ) AS EMAIL,
            NULL AS DISPLAY_NAME,
            CASE ORACLE_SQL_ADMIN_USERS.ROLE WHEN 'Administrator' THEN 3 WHEN 'Manager' THEN 2 ELSE 1 END AS ROLE_ID,
            NULL AS DISCLAIMER_ACCEPTED_ON,
            'N' AS IS_BLOCKED,
            FROM_TZ( ORACLE_SQL_ADMIN_USERS.CREATED, '-8:00' ) AS CREATED_ON,
            FROM_TZ( ORACLE_SQL_ADMIN_USERS.UPDATED, '-8:00' ) AS UPDATED_ON
        FROM
            ORACLE_SQL_ADMIN_USERS
    ),
    OTHER_USERS AS (
        SELECT
            NULL AS ID,
            EMAIL,
            NULL AS DISPLAY_NAME,
            1 AS ROLE_ID,
            NULL AS DISCLAIMER_ACCEPTED_ON,
            'N' AS IS_BLOCKED,
            NULL AS CREATED_ON,
            NULL AS UPDATED_ON
        FROM
            (
                SELECT
                    DISTINCT UPPER( EMAIL ) AS EMAIL
                FROM
                    (
                        SELECT
                            CREATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_ADMIN_USERS
                        UNION ALL
                        SELECT
                            UPDATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_ADMIN_USERS
                        UNION ALL
                        SELECT
                            CREATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_PUBLISHED_CONTENT
                        UNION ALL
                        SELECT
                            UPDATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_PUBLISHED_CONTENT
                        UNION ALL
                        SELECT
                            CREATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_TUT_MODULES
                        UNION ALL
                        SELECT
                            UPDATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_TUT_MODULES
                        UNION ALL
                        SELECT
                            CREATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_TUTORIALS
                        UNION ALL
                        SELECT
                            UPDATED_BY AS EMAIL
                        FROM
                            ORACLE_SQL_TUTORIALS
                        UNION ALL
                        SELECT
                            SESSION_OWNER AS EMAIL
                        FROM
                            ORACLE_SQL_SAVED_SESSIONS
                    ) EMAILS
                WHERE
                    INSTR( EMAIL, '@' ) >= 1
                    AND UPPER( EMAIL ) NOT IN ( SELECT EMAIL FROM ADMIN_USERS )
            )
    ),
    COMBINED_USERS AS (
        SELECT * FROM ADMIN_USERS
        UNION ALL SELECT * FROM OTHER_USERS
    )
SELECT * FROM COMBINED_USERS ORDER BY CREATED_ON;
COMMIT;
DROP TABLE ORACLE_SQL_ADMIN_USERS;
-- SELECT * FROM USERS

INSERT INTO
    CONTENT_CATEGORIES (
        ID,
        LEGACY_ID,
        NAME,
        DESCRIPTION,
        CONTENT_CATEGORY_ID,
        CREATED_ON,
        UPDATED_ON
    )
WITH
    ID_MAPPING AS (
        SELECT
            ROWNUM NEW_ID,
            ID AS LEGACY_ID
        FROM
            ( SELECT * FROM ORACLE_SQL_AREAS ORDER BY NVL( CREATED, MODIFIED ) NULLS FIRST )
    )
SELECT
    ID_MAPPING.NEW_ID AS ID,
    ORACLE_SQL_AREAS.ID AS LEGACY_ID,
    ORACLE_SQL_AREAS.AREA_NAME AS NAME,
    ORACLE_SQL_AREAS.AREA_DESCRIPTION AS DESCRIPTION,
    PARENT_ID_MAPPING.NEW_ID AS CONTENT_CATEGORY_ID,
    FROM_TZ( NVL( CREATED, MODIFIED ), '-8:00' ) AS CREATED_ON,
    FROM_TZ( NVL( MODIFIED, CREATED ),  '-8:00' ) AS UPDATED_ON
FROM
    ORACLE_SQL_AREAS LEFT JOIN ID_MAPPING ON
        ORACLE_SQL_AREAS.ID = ID_MAPPING.LEGACY_ID
    LEFT JOIN ID_MAPPING PARENT_ID_MAPPING ON
        ORACLE_SQL_AREAS.PARENT_ID = PARENT_ID_MAPPING.LEGACY_ID
ORDER BY
    CREATED_ON NULLS FIRST;
COMMIT;
ALTER TABLE
    CONTENT_CATEGORIES
MODIFY
    ID GENERATED BY DEFAULT ON NULL AS IDENTITY ( START WITH LIMIT VALUE );
DROP TABLE ORACLE_SQL_AREAS;
-- SELECT * FROM CONTENT_CATEGORIES
INSERT INTO
    TUTORIALS (
        ID,
        LEGACY_ID,
        TITLE,
        DESCRIPTION,
        MINIMUM_DATABASE_VERSION,
        SETUP_CODE,
        SETUP_CODE_LANGUAGE,
        SETUP_DESCRIPTION,
        CONTENT_CATEGORY_ID,
        SHARE_KEY,
        TAGS,
        IS_PUBLISHED,
        IS_FEATURED,
        LEGACY_FILE_NAME,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    )
WITH
    TUTORIALS_FILE_NAMES AS (
        SELECT
            DISTINCT
                CONTENT_ID,
                FILENAME
        FROM 
            ORACLE_SQL_PUBLISHED_CONTENT
        WHERE
            CONTENT_TYPE = 'Tutorial'
    )
SELECT
    NULL AS ID,
    ORACLE_SQL_TUTORIALS.ID AS LEGACY_ID,
    NVL( ORACLE_SQL_TUTORIALS.TUTORIAL_NAME, UTILITIES.GET_RANDOM_MIXED_ALNUM_STRING( 10 ) ) AS TITLE,
    ORACLE_SQL_TUTORIALS.TUTORIAL_OVERVIEW AS DESCRIPTION,
    NULL AS MINIMUM_DATABASE_VERSION,
    /*
     *  NOTE: This concatenation '```sql' || CHR( 10 ) || <SETUP_CODE> || CHR( 10 ) || '```'
     *        is necessary to render the legacy setup_code as a markdown SQL block.
     *
     *        Check if SETUP_CODE CLOB is NULL or empty. Returns NULL if no value is present
     *        DBMS_LOB.GETLENGTH( SETUP_CODE ) is used to determine the length of the CLOB.
     *        If SETUP_CODE is NULL, it indicates that there is no data present in the column.
     *        If DBMS_LOB.GETLENGTH( SETUP_CODE ) = 0, it means the CLOB has been initialized but contains no content.
     *
     */
    CASE WHEN ORACLE_SQL_TUTORIALS.SETUP_SQL IS NULL OR DBMS_LOB.GETLENGTH( ORACLE_SQL_TUTORIALS.SETUP_SQL ) = 0 THEN NULL ELSE '```sql' || CHR( 10 ) || ORACLE_SQL_TUTORIALS.SETUP_SQL || CHR( 10 ) || '```' END AS SETUP_CODE,
    'PL_SQL' AS SETUP_CODE_LANGUAGE,
    ORACLE_SQL_TUTORIALS.SETUP_DESCRIPTION,
    CONTENT_CATEGORIES.ID AS CONTENT_CATEGORY_ID,
    NULL AS SHARE_KEY,
    ORACLE_SQL_TUTORIALS.TAGS,
    CASE ORACLE_SQL_TUTORIALS.PUBLISHED WHEN 'Y' THEN 'Y' ELSE 'N' END AS IS_PUBLISHED,
    CASE ORACLE_SQL_TUTORIALS.FEATURED WHEN 'Y' THEN 'Y' ELSE 'N' END AS IS_FEATURED,
    TUTORIALS_FILE_NAMES.FILENAME AS LEGACY_FILE_NAME,
    CASE WHEN NVL( INSTR( ORACLE_SQL_TUTORIALS.CREATED_BY, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_TUTORIALS.CREATED_BY ) END AS CREATED_BY,
    FROM_TZ( ORACLE_SQL_TUTORIALS.CREATED, '-8:00' ) AS CREATED_ON,
    CASE WHEN NVL( INSTR( ORACLE_SQL_TUTORIALS.UPDATED_BY, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_TUTORIALS.UPDATED_BY ) END AS UPDATED_BY,
    FROM_TZ( ORACLE_SQL_TUTORIALS.UPDATED, '-8:00' )  AS UPDATED_ON
FROM
    ORACLE_SQL_TUTORIALS LEFT JOIN CONTENT_CATEGORIES ON
        ORACLE_SQL_TUTORIALS.AREA_ID = CONTENT_CATEGORIES.LEGACY_ID
    LEFT JOIN TUTORIALS_FILE_NAMES ON
        ORACLE_SQL_TUTORIALS.ID = TUTORIALS_FILE_NAMES.CONTENT_ID
ORDER BY
    CREATED_ON NULLS FIRST;
COMMIT;
DROP TABLE ORACLE_SQL_TUTORIALS;
-- SELECT * FROM TUTORIALS
INSERT INTO
    TUTORIALS_STEPS (
        ID,
        LEGACY_ID,
        TUTORIAL_ID,
        SEQUENCE,
        TITLE,
        CONTENT,
        FORMAT,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    )
SELECT
    NULL ID,
    ORACLE_SQL_TUT_MODULES.ID AS LEGACY_ID,
    TUTORIALS.ID AS TUTORIAL_ID,
    /*
     *  NOTE: This generates a unique sequence for a tutorial step within a 
     *        tutorial based on the display_seq and the created columns. This
     *        is because the production export of the table had duplicate
     *        sequences that need to be unique for this data model
     */
    ROW_NUMBER() OVER ( PARTITION BY ORACLE_SQL_TUT_MODULES.TUTORIAL_ID ORDER BY ORACLE_SQL_TUT_MODULES.DISPLAY_SEQ, ORACLE_SQL_TUT_MODULES.CREATED ) AS SEQUENCE,
    ORACLE_SQL_TUT_MODULES.NAME AS TITLE,
    CASE WHEN ORACLE_SQL_TUT_MODULES.CONTENT IS NULL THEN TO_CLOB( 'No content' ) ELSE ORACLE_SQL_TUT_MODULES.CONTENT END AS CONTENT,
    'HTML',
    CASE WHEN NVL( INSTR( ORACLE_SQL_TUT_MODULES.CREATED_BY, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_TUT_MODULES.CREATED_BY ) END AS CREATED_BY,
    FROM_TZ( ORACLE_SQL_TUT_MODULES.CREATED, '-8:00' ) AS CREATED_ON,
    CASE WHEN NVL( INSTR( ORACLE_SQL_TUT_MODULES.UPDATED_BY, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_TUT_MODULES.UPDATED_BY ) END AS UPDATED_BY,
    FROM_TZ( ORACLE_SQL_TUT_MODULES.UPDATED, '-8:00' ) AS UPDATED_ON
FROM
    ORACLE_SQL_TUT_MODULES JOIN TUTORIALS ON
        ORACLE_SQL_TUT_MODULES.TUTORIAL_ID = TUTORIALS.LEGACY_ID
ORDER BY
    CREATED_ON NULLS FIRST;
COMMIT;
DROP TABLE ORACLE_SQL_TUT_MODULES;
-- SELECT * FROM TUTORIALS_STEPS

INSERT INTO
    SCRIPTS (
        ID,
        LEGACY_ID,
        TITLE,
        DESCRIPTION,
        MINIMUM_DATABASE_VERSION,
        TAGS,
        SHARE_KEY,
        CONTENT_CATEGORY_ID,
        IS_PUBLISHED,
        IS_FEATURED,
        LEGACY_FILE_NAME,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    )
WITH
    SCRIPTS_FILE_NAMES AS (
        SELECT
            DISTINCT
                CONTENT_ID,
                FILENAME
        FROM 
            ORACLE_SQL_PUBLISHED_CONTENT
        WHERE
            CONTENT_TYPE = 'Script'
    )
SELECT
    NULL AS ID,
    ORACLE_SQL_SAVED_SESSIONS.ID AS LEGACY_ID,
    NVL( ORACLE_SQL_SAVED_SESSIONS.SESSION_NAME, UTILITIES.GET_RANDOM_MIXED_ALNUM_STRING( 10 ) ) AS TITLE,
    NVL( CASE WHEN NVL( DBMS_LOB.GETLENGTH( ORACLE_SQL_SAVED_SESSIONS.LONG_DESCRIPTION ), 0 ) > 0 THEN ORACLE_SQL_SAVED_SESSIONS.LONG_DESCRIPTION END, ORACLE_SQL_SAVED_SESSIONS.SHORT_DESCRIPTION ) AS DESCRIPTION,
    NULL AS MINIMUM_DATABASE_VERSION,
    ORACLE_SQL_SAVED_SESSIONS.TAGS,
    ORACLE_SQL_SAVED_SESSIONS.SHARE_KEY,
    CONTENT_CATEGORIES.ID AS CONTENT_CATEGORY_ID,
    CASE WHEN ORACLE_SQL_SAVED_SESSIONS.VISIBILITY = 'PUBLIC' THEN 'Y' ELSE 'N' END AS IS_PUBLISHED,
    CASE WHEN ORACLE_SQL_SAVED_SESSIONS.FEATURED = 'Y' THEN 'Y' ELSE 'N' END AS IS_FEATURED,
    SCRIPTS_FILE_NAMES.FILENAME AS LEGACY_FILE_NAME,
    CASE WHEN NVL( INSTR( ORACLE_SQL_SAVED_SESSIONS.SESSION_OWNER, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_SAVED_SESSIONS.SESSION_OWNER ) END AS CREATED_BY,
    FROM_TZ( ORACLE_SQL_SAVED_SESSIONS.CREATED, '-8:00' ) AS CREATED_ON,
    CASE WHEN NVL( INSTR( ORACLE_SQL_SAVED_SESSIONS.SESSION_OWNER, '@' ), 0 ) >= 1 THEN UPPER( ORACLE_SQL_SAVED_SESSIONS.SESSION_OWNER ) END AS UPDATED_BY,
    FROM_TZ( ORACLE_SQL_SAVED_SESSIONS.MODIFIED, '-8:00' ) AS UPDATED_ON
FROM
    ORACLE_SQL_SAVED_SESSIONS LEFT JOIN CONTENT_CATEGORIES ON
        ORACLE_SQL_SAVED_SESSIONS.AREA1_ID = CONTENT_CATEGORIES.LEGACY_ID
    LEFT JOIN SCRIPTS_FILE_NAMES ON
        ORACLE_SQL_SAVED_SESSIONS.ID = SCRIPTS_FILE_NAMES.CONTENT_ID
ORDER BY
    CREATED_ON;
COMMIT;
DROP TABLE ORACLE_SQL_SAVED_SESSIONS;
-- SELECT * FROM SCRIPTS

INSERT INTO
    SCRIPTS_STATEMENTS (
        ID,
        LEGACY_ID,
        SCRIPT_ID,
        SEQUENCE,
        TITLE,
        CONTENT,
        EXPECTED_RESULT,
        CREATED_BY,
        CREATED_ON,
        UPDATED_BY,
        UPDATED_ON
    )
SELECT
    NULL AS ID,
    ORACLE_SQL_SAVED_STATEMENTS.ID AS LEGACY_ID,
    SCRIPTS.ID AS SCRIPT_ID,
    /*
     *  NOTE: This generates a unique sequence for a script statement within a 
     *        script based on the esecution_sequence and the created columns.
     *        This is because the production export of the table had duplicate
     *        sequences that need to be unique for this data model
     */
    ROW_NUMBER() OVER ( PARTITION BY ORACLE_SQL_SAVED_STATEMENTS.SAVED_SESSION_ID ORDER BY ORACLE_SQL_SAVED_STATEMENTS.EXECUTION_SEQUENCE, ORACLE_SQL_SAVED_STATEMENTS.CREATED ) AS SEQUENCE,
    ORACLE_SQL_SAVED_STATEMENTS.STATEMENT_TITLE AS TITLE,
    /*
     *  NOTE: This concatenation '```sql' || CHR( 10 ) || <STATEMENT> || CHR( 10 ) || '```'
     *        is necessary to render the legacy statements as a markdown SQL block.
     */
    CASE WHEN ORACLE_SQL_SAVED_STATEMENTS.STATEMENT IS NULL THEN TO_CLOB( 'No content' ) ELSE '```sql' || CHR( 10 ) || ORACLE_SQL_SAVED_STATEMENTS.STATEMENT || CHR( 10 ) || '```' END AS CONTENT,
    NULL AS EXPECTED_RESULT,
    CASE WHEN NVL( INSTR( SCRIPTS.CREATED_BY, '@' ), 0 ) >= 1 THEN UPPER( SCRIPTS.CREATED_BY ) END AS CREATED_BY,
    FROM_TZ( ORACLE_SQL_SAVED_STATEMENTS.CREATED, '-8:00' ) AS CREATED_ON,
    CASE WHEN NVL( INSTR( SCRIPTS.UPDATED_BY, '@' ), 0 ) >= 1 THEN UPPER( SCRIPTS.UPDATED_BY ) END AS UPDATED_BY,
    FROM_TZ( ORACLE_SQL_SAVED_STATEMENTS.MODIFIED, '-8:00' ) AS UPDATED_ON
FROM
    ORACLE_SQL_SAVED_STATEMENTS JOIN SCRIPTS ON
        ORACLE_SQL_SAVED_STATEMENTS.SAVED_SESSION_ID = SCRIPTS.LEGACY_ID
ORDER BY
    CREATED_ON;
COMMIT;
DROP TABLE ORACLE_SQL_SAVED_STATEMENTS;
-- SELECT * FROM SCRIPTS_STATEMENTS
DROP TABLE ORACLE_SQL_PUBLISHED_CONTENT;

PROMPT INFO: Live SQL METADATA Legacy Data Migrated
